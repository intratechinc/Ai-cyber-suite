<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberGuard AI - Security Management Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e5e5e5;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Icon styles */
        .icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            text-align: center;
        }
        
        .icon-shield::before { content: "üõ°Ô∏è"; }
        .icon-user-secret::before { content: "üïµÔ∏è"; }
        .icon-search::before { content: "üîç"; }
        .icon-virus::before { content: "ü¶†"; }
        .icon-robot::before { content: "ü§ñ"; }
        .icon-user::before { content: "üë§"; }
        .icon-check::before { content: "‚úì"; }
        .icon-times::before { content: "‚úï"; }
        .icon-info::before { content: "‚Ñπ"; }
        .icon-dashboard::before { content: "üìä"; }
        .icon-users::before { content: "üë•"; }
        .icon-desktop::before { content: "üñ•Ô∏è"; }
        .icon-network::before { content: "üåê"; }
        .icon-clipboard-check::before { content: "üìã"; }
        .icon-exclamation-triangle::before { content: "‚ö†Ô∏è"; }
        .icon-lock::before { content: "üîí"; }
        .icon-key::before { content: "üîë"; }
        .icon-eye::before { content: "üëÅÔ∏è"; }
        .icon-refresh::before { content: "üîÑ"; }

        /* Layout */
        .dashboard-container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .sidebar.mobile {
            transform: translateX(-100%);
        }

        .logo {
            padding: 2rem 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .logo h1 {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00d4ff, #0066cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .logo .subtitle {
            font-size: 0.8rem;
            color: #888;
            margin-top: 0.5rem;
        }

        .nav-menu {
            padding: 1rem 0;
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 1rem 1.5rem;
            color: #b8b8b8;
            text-decoration: none;
            transition: all 0.3s ease;
            cursor: pointer;
            border-left: 3px solid transparent;
        }

        .nav-link:hover, .nav-link.active {
            background: rgba(0, 212, 255, 0.1);
            color: #00d4ff;
            border-left-color: #00d4ff;
        }

        .nav-link .icon {
            margin-right: 1rem;
            font-size: 1.1rem;
        }

        /* Main content */
        .main-content {
            flex: 1;
            margin-left: 280px;
            padding: 2rem;
            transition: all 0.3s ease;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .page-title {
            font-size: 2rem;
            font-weight: 600;
            color: #fff;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff, #0066cc);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e5e5e5;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
        }

        /* Content sections */
        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        /* Status cards grid */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .status-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            transform: translateY(-5px);
        }

        .status-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .status-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .status-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-size: 1.2rem;
        }

        .status-value {
            font-size: 2rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 0.5rem;
        }

        .status-label {
            color: #b8b8b8;
            font-size: 0.9rem;
        }

        .status-change {
            font-size: 0.8rem;
            margin-top: 0.5rem;
        }

        .status-change.positive {
            color: #10b981;
        }

        .status-change.negative {
            color: #ef4444;
        }

        /* Agent cards */
        .agents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .agent-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .agent-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #00d4ff, #0066cc);
        }

        .agent-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 212, 255, 0.2);
        }

        .agent-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .agent-avatar {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: linear-gradient(135deg, #00d4ff, #0066cc);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-size: 1.5rem;
        }

        .agent-info h3 {
            color: #fff;
            margin-bottom: 0.25rem;
        }

        .agent-role {
            color: #b8b8b8;
            font-size: 0.9rem;
        }

        .agent-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 2rem;
            right: 2rem;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            transform: translateX(400px);
            transition: all 0.3s ease;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            max-width: 400px;
        }

        .notification.show {
            transform: translateX(0);
        }

        /* Chat modal */
        .chat-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .chat-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .chat-container {
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        .chat-modal.active .chat-container {
            transform: scale(1);
        }

        .chat-header {
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chat-agent-info {
            display: flex;
            align-items: center;
        }

        .chat-agent-avatar {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: linear-gradient(135deg, #00d4ff, #0066cc);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
        }

        .chat-close {
            background: none;
            border: none;
            color: #b8b8b8;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .chat-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .chat-messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .message {
            display: flex;
            gap: 0.75rem;
            max-width: 80%;
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background: linear-gradient(135deg, #00d4ff, #0066cc);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        .message.user .message-avatar {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .message-content {
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem 1rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .message.user .message-content {
            background: rgba(0, 212, 255, 0.1);
            border-color: rgba(0, 212, 255, 0.2);
        }

        .message-time {
            font-size: 0.7rem;
            color: #888;
            margin-top: 0.5rem;
        }

        .typing-indicator {
            display: flex;
            gap: 2px;
            padding: 0.5rem 0;
        }

        .typing-indicator span {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #00d4ff;
            animation: typing 1.4s infinite ease-in-out;
        }

        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.5;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .chat-suggestions {
            padding: 0 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .chat-suggestion {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.2);
            padding: 0.5rem 0.75rem;
            border-radius: 16px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chat-suggestion:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-1px);
        }

        .chat-input-container {
            padding: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .input-row {
            display: flex;
            gap: 0.75rem;
            align-items: flex-end;
        }

        .task-dropdown {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0.75rem;
            color: #e5e5e5;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .task-dropdown:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
        }

        .task-dropdown option {
            background: #1a1a2e;
            color: #e5e5e5;
            padding: 0.5rem;
        }

        .dropdown-btn {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: #00d4ff;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .dropdown-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-1px);
        }

        .chat-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0.75rem;
            color: #e5e5e5;
            resize: none;
            min-height: 40px;
            max-height: 120px;
            font-family: inherit;
        }

        .chat-input:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
        }

        .chat-send {
            background: linear-gradient(135deg, #00d4ff, #0066cc);
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chat-send:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }

        /* Progress bars */
        .progress-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            height: 8px;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #0066cc);
            border-radius: 10px;
            transition: width 1s ease;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }
            
            .main-content {
                margin-left: 0;
                padding: 1rem;
            }
            
            .status-grid, .agents-grid {
                grid-template-columns: 1fr;
            }
            
            .chat-container {
                width: 95%;
                height: 90vh;
            }
        }

        /* Card hover effects */
        .card {
            transition: all 0.3s ease;
        }

        .card.clickable {
            cursor: pointer;
        }

        .card.clickable:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        /* Additional status card colors */
        .status-secure { background: linear-gradient(135deg, #10b981, #059669); }
        .status-warning { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .status-critical { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .status-info { background: linear-gradient(135deg, #3b82f6, #2563eb); }

        /* Task execution and results styling */
        .task-message {
            border-left: 3px solid #00d4ff;
        }

        .task-content {
            background: rgba(0, 212, 255, 0.05);
            border-color: rgba(0, 212, 255, 0.2);
        }

        .task-header {
            font-weight: 600;
            color: #00d4ff;
            margin-bottom: 0.5rem;
        }

        .progress-message {
            border-left: 3px solid #f59e0b;
        }

        .task-progress {
            margin: 0.5rem 0;
        }

        .progress-text {
            font-size: 0.9rem;
            color: #e5e5e5;
            margin-bottom: 0.5rem;
        }

        .results-message {
            border-left: 3px solid #10b981;
        }

        .results-content {
            background: rgba(16, 185, 129, 0.05);
            border-color: rgba(16, 185, 129, 0.2);
        }

        .task-results {
            margin: 0.5rem 0;
        }

        .results-header {
            font-weight: 700;
            color: #10b981;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .results-list {
            margin: 1rem 0;
        }

        .result-item {
            background: rgba(255, 255, 255, 0.02);
            padding: 0.5rem 0.75rem;
            margin: 0.25rem 0;
            border-radius: 6px;
            border-left: 2px solid rgba(16, 185, 129, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .task-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .task-action-btn {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: #00d4ff;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }

        .task-action-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-1px);
        }

        /* Enhanced message content for formatted text */
        .message-content {
            white-space: pre-line;
        }

        /* Tool and capability display */
        .capabilities-list {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            padding: 1rem;
            margin: 0.5rem 0;
        }

        .tools-available {
            color: #00d4ff;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .capability-item {
            color: #b8b8b8;
            margin: 0.25rem 0;
            font-size: 0.9rem;
        }

        /* Enhanced progress bar animation */
        .progress-fill {
            transition: width 0.5s ease-in-out;
            background: linear-gradient(90deg, #00d4ff, #0066cc, #00d4ff);
            background-size: 200% 100%;
            animation: progressShine 2s infinite;
        }

        @keyframes progressShine {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Task status indicators */
        .task-status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: #888;
            margin-top: 0.5rem;
        }

        .status-running::before {
            content: "üîÑ";
            animation: spin 2s linear infinite;
        }

        .status-completed::before {
            content: "‚úÖ";
        }

        .status-failed::before {
            content: "‚ùå";
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Real-time task queue display */
        .task-queue-indicator {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            min-width: 250px;
            max-width: 350px;
            transform: translateX(-400px);
            transition: all 0.3s ease;
            z-index: 9000;
        }

        .task-queue-indicator.show {
            transform: translateX(0);
        }

        .queue-header {
            font-weight: 600;
            color: #00d4ff;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .active-task {
            background: rgba(255, 255, 255, 0.02);
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 4px;
            border-left: 2px solid #f59e0b;
            font-size: 0.8rem;
        }

        /* Network Devices Modal Styles */
        .device-scanning {
            text-align: center;
            padding: 40px 20px;
            color: #9ca3af;
        }

        .scanning-indicator {
            margin-bottom: 15px;
        }

        .scanning-indicator .icon {
            font-size: 24px;
            animation: spin 1s linear infinite;
        }

        .device-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #374151;
            transition: background-color 0.2s ease;
        }

        .device-item:hover {
            background-color: #374151;
        }

        .device-item:last-child {
            border-bottom: none;
        }

        .device-icon {
            margin-right: 15px;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .device-icon .icon {
            color: white;
            font-size: 18px;
        }

        .device-info {
            flex: 1;
        }

        .device-name {
            font-weight: 600;
            color: #f9fafb;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .device-details {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 5px;
        }

        .device-ip {
            color: #d1d5db;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .device-status {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
        }

        .device-status.online {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .device-status.detected {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .device-meta {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #9ca3af;
        }

        .device-meta span {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <!-- Notification -->
    <div id="notification" class="notification">
        <span class="icon icon-check"></span>
        <span id="notification-text">Notification message</span>
    </div>

    <!-- Main Dashboard Container -->
    <div class="dashboard-container">
        <!-- Sidebar -->
        <aside id="sidebar" class="sidebar">
            <div class="logo">
                <h1>CyberGuard AI</h1>
                <div class="subtitle">Enterprise Security Platform</div>
            </div>
            
            <nav class="nav-menu">
                <a href="#" class="nav-link active" data-section="dashboard">
                    <span class="icon icon-dashboard"></span>
                    Security Dashboard
                </a>
                <a href="#" class="nav-link" data-section="agents">
                    <span class="icon icon-robot"></span>
                    AI Security Agents
                </a>
                <a href="#" class="nav-link" data-section="identity">
                    <span class="icon icon-key"></span>
                    Identity Management
                </a>
                <a href="#" class="nav-link" data-section="endpoints">
                    <span class="icon icon-desktop"></span>
                    Device Management
                </a>
                <a href="#" class="nav-link" data-section="users">
                    <span class="icon icon-users"></span>
                    User Access Control
                </a>
                <a href="#" class="nav-link" data-section="network">
                    <span class="icon icon-network"></span>
                    Network Security
                </a>
                <a href="#" class="nav-link" data-section="compliance">
                    <span class="icon icon-clipboard-check"></span>
                    Compliance & Auditing
                </a>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Header -->
            <header class="header">
                <h1 id="page-title" class="page-title">Security Dashboard</h1>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="syncSystems()">
                        <span class="icon icon-refresh"></span>
                        Sync Systems
                    </button>
                    <button class="btn btn-primary" onclick="runSecurityScan()">
                        <span class="icon icon-shield"></span>
                        Run Security Scan
                    </button>
                </div>
            </header>

            <!-- Dashboard Content -->
            <div id="dashboard-content" class="content-section active">
                <div class="status-grid">
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-secure">
                                <span class="icon icon-shield"></span>
                            </div>
                            <div>
                                <div class="status-value">98%</div>
                                <div class="status-label">Security Score</div>
                                <div class="status-change positive">+2% from last week</div>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 98%"></div>
                        </div>
                    </div>

                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-info">
                                <span class="icon icon-users"></span>
                            </div>
                            <div>
                                <div class="status-value">247</div>
                                <div class="status-label">Active Users</div>
                                <div class="status-change positive">+12 new this month</div>
                            </div>
                        </div>
                    </div>

                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-warning">
                                <span class="icon icon-exclamation-triangle"></span>
                            </div>
                            <div>
                                <div class="status-value">3</div>
                                <div class="status-label">Security Alerts</div>
                                <div class="status-change negative">2 high priority</div>
                            </div>
                        </div>
                    </div>

                    <div class="status-card clickable" onclick="showNetworkDevices()">
                        <div class="status-header">
                            <div class="status-icon status-info">
                                <span class="icon icon-network"></span>
                            </div>
                            <div>
                                <div class="status-value">-</div>
                                <div class="status-label">Network Devices</div>
                                <div class="status-change">Discovering devices...</div>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="agents-grid">
                    <div class="card clickable" onclick="navigateToSection('agents')">
                        <div class="agent-header">
                            <div class="agent-avatar">
                                <span class="icon icon-robot"></span>
                            </div>
                            <div class="agent-info">
                                <h3>AI Security Agents</h3>
                                <div class="agent-role">4 active agents monitoring</div>
                            </div>
                        </div>
                        <div class="agent-status">
                            <div class="status-indicator"></div>
                            <span>All systems operational</span>
                        </div>
                    </div>

                    <div class="card clickable" onclick="navigateToSection('identity')">
                        <div class="agent-header">
                            <div class="agent-avatar">
                                <span class="icon icon-key"></span>
                            </div>
                            <div class="agent-info">
                                <h3>Identity Management</h3>
                                <div class="agent-role">Active Directory integration</div>
                            </div>
                        </div>
                        <div class="agent-status">
                            <div class="status-indicator"></div>
                            <span>Synchronized 2 minutes ago</span>
                        </div>
                    </div>

                    <div class="card clickable" onclick="navigateToSection('endpoints')">
                        <div class="agent-header">
                            <div class="agent-avatar">
                                <span class="icon icon-desktop"></span>
                            </div>
                            <div class="agent-info">
                                <h3>Endpoint Protection</h3>
                                <div class="agent-role">Real-time monitoring</div>
                            </div>
                        </div>
                        <div class="agent-status">
                            <div class="status-indicator"></div>
                            <span>192 devices protected</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- AI Agents Content -->
            <div id="agents-content" class="content-section">
                <div class="agents-grid">
                    <div class="agent-card" onclick="openAgentChat('redteam')">
                        <div class="agent-header">
                            <div class="agent-avatar">
                                <span class="icon icon-user-secret"></span>
                            </div>
                            <div class="agent-info">
                                <h3>RedTeam Alpha</h3>
                                <div class="agent-role">Penetration Testing Specialist</div>
                            </div>
                        </div>
                        <p>Simulates real-world attacks to identify vulnerabilities and security weaknesses before they can be exploited.</p>
                        <div class="agent-status">
                            <div class="status-indicator"></div>
                            <span>Online - Ready for testing</span>
                        </div>
                    </div>

                    <div class="agent-card" onclick="openAgentChat('threathunter')">
                        <div class="agent-header">
                            <div class="agent-avatar">
                                <span class="icon icon-search"></span>
                            </div>
                            <div class="agent-info">
                                <h3>ThreatHunter X1</h3>
                                <div class="agent-role">Threat Detection Specialist</div>
                            </div>
                        </div>
                        <p>Proactively hunts for threats using behavioral analytics and threat intelligence to detect advanced persistent threats.</p>
                        <div class="agent-status">
                            <div class="status-indicator"></div>
                            <span>Online - Monitoring network</span>
                        </div>
                    </div>

                    <div class="agent-card" onclick="openAgentChat('malware')">
                        <div class="agent-header">
                            <div class="agent-avatar">
                                <span class="icon icon-virus"></span>
                            </div>
                            <div class="agent-info">
                                <h3>MalwareScope</h3>
                                <div class="agent-role">Malware Analysis Specialist</div>
                            </div>
                        </div>
                        <p>Analyzes suspicious files and code to identify malware, create detection signatures, and provide threat intelligence.</p>
                        <div class="agent-status">
                            <div class="status-indicator"></div>
                            <span>Online - Analysis ready</span>
                        </div>
                    </div>

                    <div class="agent-card" onclick="openAgentChat('incident')">
                        <div class="agent-header">
                            <div class="agent-avatar">
                                <span class="icon icon-shield"></span>
                            </div>
                            <div class="agent-info">
                                <h3>ResponseBot</h3>
                                <div class="agent-role">Incident Response Coordinator</div>
                            </div>
                        </div>
                        <p>Coordinates incident response activities, manages crisis communications, and guides recovery procedures.</p>
                        <div class="agent-status">
                            <div class="status-indicator"></div>
                            <span>Online - Standby mode</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Identity Management Content -->
            <div id="identity-content" class="content-section">
                <div class="status-grid">
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-secure">
                                <span class="icon icon-users"></span>
                            </div>
                            <div>
                                <div class="status-value">247</div>
                                <div class="status-label">Total Users</div>
                                <div class="status-change positive">Active in system</div>
                            </div>
                        </div>
                    </div>
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-info">
                                <span class="icon icon-key"></span>
                            </div>
                            <div>
                                <div class="status-value">156</div>
                                <div class="status-label">MFA Enabled</div>
                                <div class="status-change positive">63% coverage</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Endpoints Content -->
            <div id="endpoints-content" class="content-section">
                <div class="status-grid">
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-secure">
                                <span class="icon icon-desktop"></span>
                            </div>
                            <div>
                                <div class="status-value">192</div>
                                <div class="status-label">Managed Devices</div>
                                <div class="status-change positive">100% compliant</div>
                            </div>
                        </div>
                    </div>
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-warning">
                                <span class="icon icon-exclamation-triangle"></span>
                            </div>
                            <div>
                                <div class="status-value">5</div>
                                <div class="status-label">Pending Updates</div>
                                <div class="status-change negative">Requires attention</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Users Content -->
            <div id="users-content" class="content-section">
                <div class="status-grid">
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-secure">
                                <span class="icon icon-lock"></span>
                            </div>
                            <div>
                                <div class="status-value">95%</div>
                                <div class="status-label">Access Compliance</div>
                                <div class="status-change positive">Excellent</div>
                            </div>
                        </div>
                    </div>
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-info">
                                <span class="icon icon-eye"></span>
                            </div>
                            <div>
                                <div class="status-value">12</div>
                                <div class="status-label">Login Attempts</div>
                                <div class="status-change positive">Last 24 hours</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Network Content -->
            <div id="network-content" class="content-section">
                <div class="status-grid">
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-secure">
                                <span class="icon icon-network"></span>
                            </div>
                            <div>
                                <div class="status-value">99.8%</div>
                                <div class="status-label">Network Uptime</div>
                                <div class="status-change positive">Excellent performance</div>
                            </div>
                        </div>
                    </div>
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-warning">
                                <span class="icon icon-exclamation-triangle"></span>
                            </div>
                            <div>
                                <div class="status-value">2</div>
                                <div class="status-label">Suspicious IPs</div>
                                <div class="status-change negative">Under investigation</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Compliance Content -->
            <div id="compliance-content" class="content-section">
                <div class="status-grid">
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-secure">
                                <span class="icon icon-clipboard-check"></span>
                            </div>
                            <div>
                                <div class="status-value">92%</div>
                                <div class="status-label">Compliance Score</div>
                                <div class="status-change positive">SOC 2 Type II</div>
                            </div>
                        </div>
                    </div>
                    <div class="status-card">
                        <div class="status-header">
                            <div class="status-icon status-info">
                                <span class="icon icon-clipboard-check"></span>
                            </div>
                            <div>
                                <div class="status-value">15</div>
                                <div class="status-label">Audit Findings</div>
                                <div class="status-change positive">12 resolved</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Chat Modal -->
    <div id="chatModal" class="chat-modal">
        <div class="chat-container">
            <div class="chat-header">
                <div class="chat-agent-info">
                    <div id="chatAgentAvatar" class="chat-agent-avatar">
                        <span class="icon icon-robot"></span>
                    </div>
                    <div>
                        <div id="chatAgentName">AI Agent</div>
                        <div id="chatAgentRole" class="agent-role">Cybersecurity Specialist</div>
                    </div>
                </div>
                <button class="chat-close" onclick="closeChatModal()">√ó</button>
            </div>
            
            <div id="chatMessages" class="chat-messages">
                <!-- Messages will be added here dynamically -->
            </div>
            
            <div id="chatSuggestions" class="chat-suggestions">
                <!-- Suggestions will be added here dynamically -->
            </div>
            
            <div class="chat-input-container">
                <div class="input-row">
                    <select id="taskDropdown" class="task-dropdown" onchange="executeSelectedTask()">
                        <option value="">Select a security task or tool...</option>
                    </select>
                </div>
                <div class="input-row">
                    <textarea id="chatInput" class="chat-input" placeholder="Type your message or select a task above..." rows="1"></textarea>
                    <button class="chat-send" onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Network Devices Modal -->
    <div id="networkDevicesModal" class="chat-modal">
        <div class="chat-container">
            <div class="chat-header">
                <div class="chat-agent-info">
                    <div class="chat-agent-avatar">
                        <span class="icon icon-network"></span>
                    </div>
                    <div>
                        <div>Network Devices</div>
                        <div class="agent-role">Real-time Device Discovery</div>
                    </div>
                </div>
                <button class="chat-close" onclick="closeNetworkDevicesModal()">√ó</button>
            </div>
            
            <div id="networkDevicesList" class="chat-messages">
                <div class="device-scanning">
                    <div class="scanning-indicator">
                        <span class="icon icon-spinner"></span>
                    </div>
                    <p>Scanning network for devices...</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Agent-specific task prompts for dropdown
        const agentTaskPrompts = {
            'redteam': [
                {
                    name: 'üîç Basic Network Scan',
                    prompt: 'Run vulnerability scan on 192.168.1.0/24',
                    description: 'Perform basic network discovery and vulnerability assessment'
                },
                {
                    name: 'üåê Web Application Test',
                    prompt: 'Test web application security for OWASP Top 10',
                    description: 'Comprehensive web app security testing'
                },
                {
                    name: 'üî¨ Advanced Network Reconnaissance',
                    prompt: 'Perform detailed network reconnaissance with service enumeration',
                    description: 'Deep network mapping and service identification'
                },
                {
                    name: 'üíâ SQL Injection Assessment',
                    prompt: 'Execute SQL injection test on target application',
                    description: 'Test for SQL injection vulnerabilities'
                },
                {
                    name: 'üé≠ Social Engineering Simulation',
                    prompt: 'Check for social engineering risks and user awareness',
                    description: 'Assess human factor security vulnerabilities'
                },
                {
                    name: 'üì° Wireless Security Audit',
                    prompt: 'Perform wireless network security assessment',
                    description: 'Test Wi-Fi security and identify rogue access points'
                },
                {
                    name: 'üîì Password Security Test',
                    prompt: 'Test password policies and conduct brute force simulation',
                    description: 'Assess authentication security strength'
                },
                {
                    name: 'üõ†Ô∏è Show Capabilities',
                    prompt: 'Show my tools and capabilities',
                    description: 'Display available penetration testing tools'
                },
                // Tools section
                {
                    name: '--- PENETRATION TESTING TOOLS ---',
                    prompt: '',
                    description: 'Available security tools',
                    disabled: true
                },
                {
                    name: 'üîß Nmap Network Scanner',
                    prompt: 'Use nmap to scan network for open ports and services',
                    description: 'Network discovery and security auditing'
                },
                {
                    name: 'üîß Metasploit Framework',
                    prompt: 'Launch metasploit for advanced penetration testing',
                    description: 'Exploit development and execution platform'
                },
                {
                    name: 'üîß Burp Suite Web Scanner',
                    prompt: 'Use Burp Suite for web application security testing',
                    description: 'Web vulnerability scanner and proxy'
                },
                {
                    name: 'üîß Nikto Web Scanner',
                    prompt: 'Run nikto web server scanner for vulnerabilities',
                    description: 'Web server vulnerability scanner'
                },
                {
                    name: 'üîß SQLmap Injection Tool',
                    prompt: 'Use sqlmap to test for SQL injection vulnerabilities',
                    description: 'Automated SQL injection and database takeover'
                }
            ],
            'threathunter': [
                {
                    name: 'üéØ IOC Hunt Operation',
                    prompt: 'Hunt for IOCs in network traffic and system logs',
                    description: 'Search for indicators of compromise'
                },
                {
                    name: 'üìä Behavioral Analysis',
                    prompt: 'Analyze suspicious activity patterns and anomalies',
                    description: 'Detect unusual user and system behaviors'
                },
                {
                    name: 'üìù Security Log Correlation',
                    prompt: 'Correlate security logs from multiple sources',
                    description: 'Identify patterns across security events'
                },
                {
                    name: 'üîç Memory Forensics Scan',
                    prompt: 'Perform memory analysis for hidden threats',
                    description: 'Deep memory inspection for advanced threats'
                },
                {
                    name: 'üåê Network Traffic Analysis',
                    prompt: 'Analyze network traffic for suspicious communications',
                    description: 'Inspect network flows for threat indicators'
                },
                {
                    name: '‚ö° Real-time Threat Detection',
                    prompt: 'Monitor for real-time threats and automated response',
                    description: 'Active threat monitoring and alerting'
                },
                {
                    name: 'üìã Threat Intelligence Lookup',
                    prompt: 'Check threat intelligence databases for known indicators',
                    description: 'Validate threats against global intelligence'
                },
                {
                    name: 'üõ†Ô∏è Show Capabilities',
                    prompt: 'Show my tools and capabilities',
                    description: 'Display available threat hunting tools'
                },
                // Tools section
                {
                    name: '--- THREAT HUNTING TOOLS ---',
                    prompt: '',
                    description: 'Available hunting tools',
                    disabled: true
                },
                {
                    name: 'üîß Wireshark Packet Analyzer',
                    prompt: 'Use wireshark to analyze network traffic for threats',
                    description: 'Network protocol analyzer and packet capture'
                },
                {
                    name: 'üîß Sigma Rule Engine',
                    prompt: 'Apply sigma rules for threat detection in logs',
                    description: 'Generic signature format for SIEM systems'
                },
                {
                    name: 'üîß YARA Pattern Matching',
                    prompt: 'Use YARA rules to identify and classify malware',
                    description: 'Pattern matching engine for malware research'
                },
                {
                    name: 'üîß Osquery System Monitor',
                    prompt: 'Query system state using osquery for anomalies',
                    description: 'SQL-based system instrumentation framework'
                },
                {
                    name: 'üîß Suricata IDS Engine',
                    prompt: 'Deploy suricata for network intrusion detection',
                    description: 'High performance network IDS and IPS'
                }
            ],
            'malware': [
                {
                    name: 'ü¶† File Analysis (Static)',
                    prompt: 'Analyze suspicious file for malware signatures',
                    description: 'Static analysis without execution'
                },
                {
                    name: 'üî¨ Sandbox Execution',
                    prompt: 'Run sandbox execution for behavioral analysis',
                    description: 'Safe dynamic malware analysis'
                },
                {
                    name: 'üìù YARA Rule Creation',
                    prompt: 'Create YARA signature for malware detection',
                    description: 'Generate detection rules for security tools'
                },
                {
                    name: 'üè¥‚Äç‚ò†Ô∏è Ransomware Detection',
                    prompt: 'Check for ransomware indicators and encryption behavior',
                    description: 'Specialized ransomware threat analysis'
                },
                {
                    name: 'üîç Reverse Engineering',
                    prompt: 'Perform reverse engineering analysis on binary',
                    description: 'Deep code analysis and disassembly'
                },
                {
                    name: 'üåê C2 Communication Analysis',
                    prompt: 'Analyze command and control server communications',
                    description: 'Track malware network behavior'
                },
                {
                    name: 'üìä Malware Family Classification',
                    prompt: 'Classify malware family and identify variants',
                    description: 'Determine malware type and attribution'
                },
                {
                    name: 'üìã Generate Analysis Report',
                    prompt: 'Generate comprehensive malware analysis report',
                    description: 'Detailed technical analysis documentation'
                },
                {
                    name: 'üõ†Ô∏è Show Capabilities',
                    prompt: 'Show my tools and capabilities',
                    description: 'Display available malware analysis tools'
                },
                // Tools section
                {
                    name: '--- MALWARE ANALYSIS TOOLS ---',
                    prompt: '',
                    description: 'Available analysis tools',
                    disabled: true
                },
                {
                    name: 'üîß Ghidra Reverse Engineering',
                    prompt: 'Use Ghidra for software reverse engineering analysis',
                    description: 'NSA software reverse engineering framework'
                },
                {
                    name: 'üîß Volatility Memory Analyzer',
                    prompt: 'Analyze memory dumps using Volatility framework',
                    description: 'Advanced memory forensics framework'
                },
                {
                    name: 'üîß Cuckoo Sandbox',
                    prompt: 'Execute malware in Cuckoo sandbox environment',
                    description: 'Automated malware analysis system'
                },
                {
                    name: 'üîß IDA Pro Disassembler',
                    prompt: 'Use IDA Pro for binary analysis and disassembly',
                    description: 'Industry standard disassembler and debugger'
                },
                {
                    name: 'üîß VirusTotal API Scanner',
                    prompt: 'Submit files to VirusTotal for multi-engine analysis',
                    description: 'Multi-antivirus scanning service'
                }
            ],
            'incident': [
                {
                    name: 'üö® Incident Response Activation',
                    prompt: 'Initiate incident response for suspected breach',
                    description: 'Start full incident response procedure'
                },
                {
                    name: 'üîç Digital Forensics Investigation',
                    prompt: 'Start forensic analysis and evidence collection',
                    description: 'Comprehensive digital investigation'
                },
                {
                    name: 'üîß Recovery Plan Creation',
                    prompt: 'Create recovery plan and remediation strategy',
                    description: 'Business continuity and recovery planning'
                },
                {
                    name: 'üèõÔ∏è Evidence Preservation',
                    prompt: 'Begin evidence collection and chain of custody',
                    description: 'Secure and document digital evidence'
                },
                {
                    name: '‚è∞ Timeline Reconstruction',
                    prompt: 'Reconstruct incident timeline and attack vectors',
                    description: 'Map chronological sequence of events'
                },
                {
                    name: 'üîí Containment Procedure',
                    prompt: 'Execute containment and threat isolation',
                    description: 'Stop threat spread and limit damage'
                },
                {
                    name: 'üë• Team Coordination',
                    prompt: 'Activate response team and coordinate activities',
                    description: 'Manage incident response team workflow'
                },
                {
                    name: 'üìã Post-Incident Analysis',
                    prompt: 'Conduct lessons learned and improvement analysis',
                    description: 'Review response effectiveness and improvements'
                },
                {
                    name: 'üõ†Ô∏è Show Capabilities',
                    prompt: 'Show my tools and capabilities',
                    description: 'Display available incident response tools'
                },
                // Tools section
                {
                    name: '--- INCIDENT RESPONSE TOOLS ---',
                    prompt: '',
                    description: 'Available response tools',
                    disabled: true
                },
                {
                    name: 'üîß KAPE Digital Forensics',
                    prompt: 'Use KAPE for rapid digital evidence collection',
                    description: 'Kroll Artifact Parser and Extractor'
                },
                {
                    name: 'üîß TheHive Case Management',
                    prompt: 'Create incident case in TheHive platform',
                    description: 'Scalable security incident response platform'
                },
                {
                    name: 'üîß Autopsy Digital Forensics',
                    prompt: 'Launch Autopsy for digital forensics investigation',
                    description: 'Digital forensics platform and graphical interface'
                },
                {
                    name: 'üîß MISP Threat Intelligence',
                    prompt: 'Query MISP for threat intelligence and IoCs',
                    description: 'Malware Information Sharing Platform'
                },
                {
                    name: 'üîß Velociraptor DFIR',
                    prompt: 'Deploy Velociraptor for endpoint visibility',
                    description: 'Advanced digital forensics and incident response tool'
                }
            ]
        };

        // Enhanced AI Agents with Cybersecurity Capabilities
        const agents = {
            'redteam': {
                name: 'RedTeam Alpha',
                role: 'Penetration Testing Specialist',
                icon: 'user-secret',
                tools: ['nmap', 'nikto', 'sqlmap', 'burpsuite', 'metasploit', 'gobuster'],
                capabilities: [
                    'Network reconnaissance and port scanning',
                    'Web application security testing',
                    'SQL injection and XSS testing',
                    'Vulnerability exploitation',
                    'Social engineering assessments',
                    'Wireless security testing'
                ]
            },
            'threathunter': {
                name: 'ThreatHunter X1',
                role: 'Threat Detection Specialist',
                icon: 'search',
                tools: ['yara', 'sigma', 'osquery', 'volatility', 'wireshark', 'suricata'],
                capabilities: [
                    'IOC hunting and threat intelligence',
                    'Behavioral analysis and anomaly detection',
                    'Network traffic analysis',
                    'Log correlation and SIEM integration',
                    'Memory forensics and analysis',
                    'Custom rule creation and deployment'
                ]
            },
            'malware': {
                name: 'MalwareScope',
                role: 'Malware Analysis Specialist',
                icon: 'virus',
                tools: ['cuckoo', 'virustotal', 'ida', 'ghidra', 'strings', 'pestudio'],
                capabilities: [
                    'Static and dynamic malware analysis',
                    'Reverse engineering and disassembly',
                    'Sandbox execution and behavior monitoring',
                    'Hash and signature generation',
                    'Threat attribution and family classification',
                    'IoC extraction and reporting'
                ]
            },
            'incident': {
                name: 'ResponseBot',
                role: 'Incident Response Coordinator',
                icon: 'shield',
                tools: ['thehive', 'misp', 'volatility', 'autopsy', 'sleuthkit', 'plaso'],
                capabilities: [
                    'Incident workflow automation',
                    'Evidence collection and preservation',
                    'Timeline analysis and reconstruction',
                    'Threat intelligence integration',
                    'Containment and eradication procedures',
                    'Recovery and lessons learned documentation'
                ]
            }
        };

        // Real-time data collection system
        const taskQueue = [];
        const activeTasks = new Map();
        let taskIdCounter = 1;
        let networkData = {};
        let systemStats = {};
        let securityMetrics = {};

        // Real-time network and security data collection
        class RealTimeSecurityPlatform {
            constructor() {
                this.networkInfo = {};
                this.securityStatus = {};
                this.monitoringInterval = null;
                this.initialize();
            }

            async initialize() {
                await this.collectNetworkInfo();
                await this.initializeSecurityMonitoring();
                this.startRealTimeMonitoring();
            }

            async collectNetworkInfo() {
                try {
                    // Get real client IP and network information
                    const ipResponse = await fetch('https://api.ipify.org?format=json');
                    const ipData = await ipResponse.json();
                    this.networkInfo.publicIP = ipData.ip;

                    // Get detailed network information
                    const networkResponse = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
                    const networkData = await networkResponse.json();
                    
                    this.networkInfo = {
                        ...this.networkInfo,
                        city: networkData.city,
                        region: networkData.region,
                        country: networkData.country_name,
                        isp: networkData.org,
                        timezone: networkData.timezone,
                        latitude: networkData.latitude,
                        longitude: networkData.longitude
                    };

                    // Get local network information using WebRTC
                    await this.getLocalNetworkInfo();
                    
                } catch (error) {
                    console.error('Error collecting network info:', error);
                    this.networkInfo = { error: 'Unable to collect network information' };
                }
            }

            async getLocalNetworkInfo() {
                return new Promise((resolve) => {
                    const pc = new RTCPeerConnection({iceServers: [{urls: 'stun:stun.l.google.com:19302'}]});
                    const localIPs = [];

                    pc.createDataChannel('');
                    pc.createOffer().then(offer => pc.setLocalDescription(offer));

                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            const ip = event.candidate.candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
                            if (ip && !localIPs.includes(ip[1])) {
                                localIPs.push(ip[1]);
                                this.networkInfo.localIPs = localIPs;
                            }
                        }
                    };

                    setTimeout(() => {
                        pc.close();
                        resolve(localIPs);
                    }, 2000);
                });
            }

            async initializeSecurityMonitoring() {
                // Check browser security features
                this.securityStatus.https = location.protocol === 'https:';
                this.securityStatus.secureContext = window.isSecureContext;
                
                // Check for security headers (simulate checking response headers)
                this.securityStatus.contentSecurityPolicy = this.checkCSP();
                this.securityStatus.strictTransportSecurity = this.checkHSTS();
                
                // Monitor WebRTC security
                this.securityStatus.webrtcEnabled = !!window.RTCPeerConnection;
                
                // Check for browser vulnerabilities
                await this.checkBrowserSecurity();
            }

            checkCSP() {
                try {
                    const meta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
                    return !!meta;
                } catch {
                    return false;
                }
            }

            checkHSTS() {
                // This would typically check response headers, simulating here
                return location.protocol === 'https:';
            }

            async checkBrowserSecurity() {
                const userAgent = navigator.userAgent;
                const browserInfo = {
                    userAgent: userAgent,
                    cookiesEnabled: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack,
                    javaEnabled: navigator.javaEnabled ? navigator.javaEnabled() : false,
                    language: navigator.language,
                    platform: navigator.platform,
                    vendor: navigator.vendor
                };

                // Check for potential security issues
                this.securityStatus.browserInfo = browserInfo;
                this.securityStatus.potentialIssues = this.identifySecurityIssues(browserInfo);
            }

            identifySecurityIssues(browserInfo) {
                const issues = [];
                
                if (!this.securityStatus.https) {
                    issues.push('Non-HTTPS connection detected');
                }
                
                if (browserInfo.javaEnabled) {
                    issues.push('Java plugin enabled (security risk)');
                }
                
                if (!browserInfo.doNotTrack) {
                    issues.push('Do Not Track not enabled');
                }
                
                // Check for outdated browser (simplified)
                if (browserInfo.userAgent.includes('Chrome')) {
                    const chromeVersion = browserInfo.userAgent.match(/Chrome\/(\d+)/);
                    if (chromeVersion && parseInt(chromeVersion[1]) < 120) {
                        issues.push('Potentially outdated browser version');
                    }
                }

                return issues;
            }

            async performNetworkScan() {
                const results = {
                    timestamp: new Date(),
                    publicIP: this.networkInfo.publicIP,
                    localIPs: this.networkInfo.localIPs || [],
                    location: `${this.networkInfo.city}, ${this.networkInfo.country}`,
                    isp: this.networkInfo.isp,
                    securityIssues: this.securityStatus.potentialIssues || [],
                    openPorts: await this.scanCommonPorts(),
                    dnsServers: await this.checkDNSServers(),
                    threats: await this.checkThreatIntelligence(),
                    networkDevices: await this.discoverNetworkDevices()
                };

                return results;
            }

            async discoverNetworkDevices() {
                const devices = [];
                
                try {
                    // Use WebRTC to discover local network devices
                    const pc = new RTCPeerConnection({
                        iceServers: [
                            {urls: 'stun:stun.l.google.com:19302'},
                            {urls: 'stun:stun1.l.google.com:19302'}
                        ]
                    });
                    
                    const discoveredIPs = new Set();
                    
                    pc.createDataChannel('');
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    return new Promise((resolve) => {
                        pc.onicecandidate = (event) => {
                            if (event.candidate) {
                                const ip = event.candidate.candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
                                if (ip && !discoveredIPs.has(ip[1])) {
                                    discoveredIPs.add(ip[1]);
                                    
                                    // Determine device type based on IP pattern
                                    const deviceInfo = this.identifyDeviceType(ip[1]);
                                    devices.push({
                                        ip: ip[1],
                                        hostname: deviceInfo.hostname,
                                        type: deviceInfo.type,
                                        manufacturer: deviceInfo.manufacturer,
                                        status: 'online',
                                        lastSeen: new Date()
                                    });
                                }
                            }
                        };
                        
                        // Additional network discovery using fetch requests
                        this.scanLocalNetwork().then(networkDevices => {
                            devices.push(...networkDevices);
                            
                            setTimeout(() => {
                                pc.close();
                                resolve(devices);
                            }, 3000);
                        });
                    });
                } catch (error) {
                    console.error('Device discovery error:', error);
                    // Fallback to basic network analysis
                    return this.getBasicNetworkInfo();
                }
            }

            identifyDeviceType(ip) {
                const segments = ip.split('.');
                const lastOctet = parseInt(segments[3]);
                
                // Common device identification patterns
                if (lastOctet === 1) {
                    return { hostname: 'Gateway/Router', type: 'router', manufacturer: 'Network Infrastructure' };
                } else if (lastOctet === 2) {
                    return { hostname: 'Secondary Router', type: 'router', manufacturer: 'Network Infrastructure' };
                } else if (lastOctet >= 100 && lastOctet <= 199) {
                    return { hostname: `Workstation-${lastOctet}`, type: 'computer', manufacturer: 'Unknown' };
                } else if (lastOctet >= 200 && lastOctet <= 249) {
                    return { hostname: `Mobile-Device-${lastOctet}`, type: 'mobile', manufacturer: 'Unknown' };
                } else if (lastOctet >= 250 && lastOctet <= 254) {
                    return { hostname: `IoT-Device-${lastOctet}`, type: 'iot', manufacturer: 'Unknown' };
                } else {
                    return { hostname: `Device-${lastOctet}`, type: 'unknown', manufacturer: 'Unknown' };
                }
            }

            async scanLocalNetwork() {
                const devices = [];
                const subnets = ['192.168.1.', '192.168.0.', '10.0.1.', '172.16.1.'];
                
                // Expanded common IP ranges including more device types
                const commonIPs = [
                    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95,
                    100, 101, 102, 103, 104, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150,
                    200, 201, 202, 203, 204, 205, 210, 215, 220, 225, 230, 235, 240, 245, 250, 251, 252, 253, 254
                ];
                
                // Try multiple subnets
                for (const subnet of subnets) {
                    for (const lastOctet of commonIPs) {
                        const ip = subnet + lastOctet;
                        try {
                            // Use Promise with timeout for faster scanning
                            await Promise.race([
                                this.testDeviceConnection(ip),
                                new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 500))
                            ]);
                            
                            const deviceInfo = this.identifyDeviceType(ip);
                            devices.push({
                                ip: ip,
                                hostname: deviceInfo.hostname,
                                type: deviceInfo.type,
                                manufacturer: deviceInfo.manufacturer,
                                status: 'detected',
                                lastSeen: new Date()
                            });
                        } catch (error) {
                            // Device not reachable or timeout
                        }
                    }
                    
                    // Break after first successful subnet to avoid too long scanning
                    if (devices.length > 0) break;
                }
                
                return devices;
            }

            async testDeviceConnection(ip) {
                // Test common ports/services
                const ports = [80, 443, 22, 23, 53, 8080];
                
                for (const port of ports) {
                    try {
                        const response = await fetch(`http://${ip}:${port}`, {
                            method: 'HEAD',
                            mode: 'no-cors',
                            timeout: 1000
                        });
                        return true; // Device responded
                    } catch (error) {
                        // Continue to next port
                    }
                }
                
                throw new Error('Device not reachable');
            }

            async getBasicNetworkInfo() {
                const devices = [];
                
                // Add current device with better detection
                const currentDevice = {
                    ip: this.networkInfo.localIPs?.[0] || 'Unknown',
                    hostname: this.getBrowserDeviceName(),
                    type: this.getCurrentDeviceType(),
                    manufacturer: navigator.platform,
                    status: 'online',
                    lastSeen: new Date()
                };
                devices.push(currentDevice);
                
                // Add multiple potential gateways
                const baseIP = this.networkInfo.localIPs?.[0]?.replace(/\.\d+$/, '.') || '192.168.1.';
                const gatewayIPs = [baseIP + '1', baseIP + '254', '192.168.0.1', '10.0.0.1', '172.16.0.1'];
                
                gatewayIPs.forEach((ip, index) => {
                    if (ip !== currentDevice.ip) {
                        devices.push({
                            ip: ip,
                            hostname: index === 0 ? 'Primary Gateway' : `Gateway-${index}`,
                            type: 'router',
                            manufacturer: 'Network Infrastructure',
                            status: 'detected',
                            lastSeen: new Date()
                        });
                    }
                });
                
                // Add common device IPs with realistic names
                const commonDevices = [
                    { ip: baseIP + '10', name: 'Network Printer', type: 'printer' },
                    { ip: baseIP + '20', name: 'WiFi Access Point', type: 'router' },
                    { ip: baseIP + '100', name: 'Workstation-100', type: 'computer' },
                    { ip: baseIP + '101', name: 'Workstation-101', type: 'computer' },
                    { ip: baseIP + '200', name: 'Mobile Device', type: 'mobile' },
                    { ip: baseIP + '250', name: 'Smart TV', type: 'iot' },
                    { ip: baseIP + '251', name: 'IoT Camera', type: 'iot' }
                ];
                
                commonDevices.forEach(device => {
                    if (device.ip !== currentDevice.ip) {
                        devices.push({
                            ip: device.ip,
                            hostname: device.name,
                            type: device.type,
                            manufacturer: 'Unknown',
                            status: Math.random() > 0.3 ? 'detected' : 'offline',
                            lastSeen: new Date(Date.now() - Math.random() * 3600000) // Random time within last hour
                        });
                    }
                });
                
                return devices;
            }

            getBrowserDeviceName() {
                const ua = navigator.userAgent;
                if (ua.includes('Mobile') || ua.includes('Android') || ua.includes('iPhone')) {
                    return 'Mobile Device';
                } else if (ua.includes('Tablet') || ua.includes('iPad')) {
                    return 'Tablet Device';
                } else if (ua.includes('Mac')) {
                    return 'Mac Computer';
                } else if (ua.includes('Windows')) {
                    return 'Windows PC';
                } else if (ua.includes('Linux')) {
                    return 'Linux Computer';
                } else {
                    return 'Current Device';
                }
            }

            getCurrentDeviceType() {
                const ua = navigator.userAgent;
                if (ua.includes('Mobile') || ua.includes('Android') || ua.includes('iPhone')) {
                    return 'mobile';
                } else if (ua.includes('Tablet') || ua.includes('iPad')) {
                    return 'tablet';
                } else {
                    return 'computer';
                }
            }

            async scanCommonPorts() {
                // Use WebSocket/fetch to test common ports (limited by CORS)
                const commonPorts = [80, 443, 22, 21, 25, 53, 110, 993, 995];
                const openPorts = [];

                for (const port of commonPorts) {
                    try {
                        // This is limited by browser security, simulating with timeout
                        const isOpen = await this.testPort(this.networkInfo.publicIP, port);
                        if (isOpen) openPorts.push(port);
                    } catch (error) {
                        // Port testing failed due to browser limitations
                    }
                }

                return openPorts.length > 0 ? openPorts : ['80', '443']; // Fallback to common web ports
            }

            async testPort(host, port) {
                return new Promise((resolve) => {
                    const timeout = setTimeout(() => resolve(false), 1000);
                    
                    try {
                        const ws = new WebSocket(`ws://${host}:${port}`);
                        ws.onopen = () => {
                            clearTimeout(timeout);
                            ws.close();
                            resolve(true);
                        };
                        ws.onerror = () => {
                            clearTimeout(timeout);
                            resolve(false);
                        };
                    } catch {
                        clearTimeout(timeout);
                        resolve(false);
                    }
                });
            }

            async checkDNSServers() {
                // Get DNS information using DNS-over-HTTPS
                try {
                    const response = await fetch('https://cloudflare-dns.com/dns-query?name=google.com&type=A', {
                        headers: { 'Accept': 'application/dns-json' }
                    });
                    const dnsData = await response.json();
                    return dnsData.Answer ? dnsData.Answer.map(a => a.data) : ['8.8.8.8'];
                } catch {
                    return ['8.8.8.8', '1.1.1.1']; // Fallback
                }
            }

            async checkThreatIntelligence() {
                try {
                    // Check IP reputation using AbuseIPDB or similar service
                    // Note: Requires API key for production use
                    const threats = [];
                    
                    // Simulate threat check based on IP geolocation
                    if (this.networkInfo.country && ['CN', 'RU', 'IR'].includes(this.networkInfo.country)) {
                        threats.push('High-risk geographical location detected');
                    }

                    return threats;
                } catch {
                    return [];
                }
            }

            async getRealTimeStats() {
                const stats = {
                    networkInfo: this.networkInfo,
                    securityStatus: this.securityStatus,
                    activeConnections: await this.getActiveConnections(),
                    memoryUsage: this.getMemoryUsage(),
                    timestamp: new Date()
                };

                return stats;
            }

            async getActiveConnections() {
                // Browser limitations prevent direct network connection monitoring
                // Using WebRTC and performance APIs as indicators
                const connections = [];
                
                if (navigator.connection) {
                    connections.push({
                        type: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt
                    });
                }

                return connections;
            }

            getMemoryUsage() {
                if ('memory' in performance) {
                    return {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    };
                }
                return { used: 0, total: 0, limit: 0 };
            }

            startRealTimeMonitoring() {
                // Update data every 30 seconds
                this.monitoringInterval = setInterval(async () => {
                    await this.updateSecurityMetrics();
                    this.updateDashboardStats();
                }, 30000);

                // Initial update
                setTimeout(() => this.updateDashboardStats(), 2000);
            }

            async updateSecurityMetrics() {
                const stats = await this.getRealTimeStats();
                
                // Calculate security score based on real factors
                let securityScore = 100;
                
                if (!this.securityStatus.https) securityScore -= 20;
                if (this.securityStatus.potentialIssues.length > 0) securityScore -= (this.securityStatus.potentialIssues.length * 10);
                if (!this.securityStatus.contentSecurityPolicy) securityScore -= 5;
                if (!this.securityStatus.strictTransportSecurity) securityScore -= 5;
                
                this.securityStatus.score = Math.max(securityScore, 0);
                this.securityStatus.lastUpdate = new Date();
            }

            updateDashboardStats() {
                // Update security score
                const scoreElement = document.querySelector('.status-grid .status-card:first-child .status-value');
                if (scoreElement && this.securityStatus.score !== undefined) {
                    scoreElement.textContent = this.securityStatus.score + '%';
                    
                    const progressBar = document.querySelector('.status-grid .status-card:first-child .progress-fill');
                    if (progressBar) {
                        progressBar.style.width = this.securityStatus.score + '%';
                    }
                }

                // Update network information
                const networkCard = document.querySelector('.status-grid .status-card:nth-child(2)');
                if (networkCard && this.networkInfo.publicIP) {
                    const valueElement = networkCard.querySelector('.status-value');
                    const labelElement = networkCard.querySelector('.status-label');
                    const changeElement = networkCard.querySelector('.status-change');
                    
                    if (valueElement) valueElement.textContent = this.networkInfo.publicIP;
                    if (labelElement) labelElement.textContent = 'Public IP Address';
                    if (changeElement) changeElement.textContent = `${this.networkInfo.city}, ${this.networkInfo.country}`;
                }

                // Update security issues count
                const alertsCard = document.querySelector('.status-grid .status-card:nth-child(3)');
                if (alertsCard && this.securityStatus.potentialIssues) {
                    const valueElement = alertsCard.querySelector('.status-value');
                    const changeElement = alertsCard.querySelector('.status-change');
                    
                    if (valueElement) valueElement.textContent = this.securityStatus.potentialIssues.length;
                    if (changeElement) {
                        if (this.securityStatus.potentialIssues.length === 0) {
                            changeElement.textContent = 'All secure';
                            changeElement.className = 'status-change positive';
                        } else {
                            changeElement.textContent = `${this.securityStatus.potentialIssues.length} issues detected`;
                            changeElement.className = 'status-change negative';
                        }
                    }
                }

                // Update connection info
                const connectionsCard = document.querySelector('.status-grid .status-card:nth-child(4)');
                if (connectionsCard && navigator.connection) {
                    const valueElement = connectionsCard.querySelector('.status-value');
                    const labelElement = connectionsCard.querySelector('.status-label');
                    const changeElement = connectionsCard.querySelector('.status-change');
                    
                    if (valueElement) valueElement.textContent = navigator.connection.effectiveType?.toUpperCase() || 'Unknown';
                    if (labelElement) labelElement.textContent = 'Connection Type';
                    if (changeElement) changeElement.textContent = `${navigator.connection.downlink || 0} Mbps downlink`;
                }

                // Update network devices count
                const devicesCard = document.querySelector('.status-grid .status-card:nth-child(4)');
                if (devicesCard) {
                    this.performNetworkScan().then(scan => {
                        const valueElement = devicesCard.querySelector('.status-value');
                        const labelElement = devicesCard.querySelector('.status-label');
                        const changeElement = devicesCard.querySelector('.status-change');
                        const progressBar = devicesCard.querySelector('.progress-fill');
                        
                        if (valueElement) valueElement.textContent = scan.networkDevices?.length || 0;
                        if (labelElement) labelElement.textContent = 'Network Devices';
                        if (changeElement) {
                            const onlineDevices = scan.networkDevices?.filter(d => d.status === 'online').length || 0;
                            changeElement.textContent = `${onlineDevices} devices online`;
                        }
                        if (progressBar) {
                            const discoveryProgress = Math.min((scan.networkDevices?.length || 0) * 20, 100);
                            progressBar.style.width = discoveryProgress + '%';
                        }
                    });
                }
            }

            stop() {
                if (this.monitoringInterval) {
                    clearInterval(this.monitoringInterval);
                    this.monitoringInterval = null;
                }
            }
        }

        // Initialize real-time security platform
        let securityPlatform = null;

        // Cybersecurity automation capabilities
        const securityTools = {
            nmap: {
                name: 'Nmap',
                description: 'Network discovery and security auditing',
                commands: {
                    'basic_scan': 'nmap -sS -O -A',
                    'stealth_scan': 'nmap -sS -T2 -f',
                    'service_scan': 'nmap -sV -sC',
                    'vuln_scan': 'nmap --script vuln'
                }
            },
            nikto: {
                name: 'Nikto',
                description: 'Web vulnerability scanner',
                commands: {
                    'basic_scan': 'nikto -h',
                    'ssl_scan': 'nikto -h -ssl',
                    'comprehensive': 'nikto -h -Tuning x'
                }
            },
            yara: {
                name: 'YARA',
                description: 'Malware identification and classification',
                commands: {
                    'scan_file': 'yara rules.yar',
                    'scan_memory': 'yara -p rules.yar',
                    'create_rule': 'yara-gen'
                }
            },
            volatility: {
                name: 'Volatility',
                description: 'Memory forensics framework',
                commands: {
                    'imageinfo': 'volatility -f memory.dmp imageinfo',
                    'pslist': 'volatility -f memory.dmp --profile= pslist',
                    'netscan': 'volatility -f memory.dmp --profile= netscan'
                }
            }
        };

        // Task execution and automation functions
        async function executeSecurityTask(agentId, taskType, parameters = {}) {
            const taskId = `task_${taskIdCounter++}`;
            const task = {
                id: taskId,
                agentId: agentId,
                type: taskType,
                parameters: parameters,
                status: 'running',
                startTime: new Date(),
                progress: 0,
                results: []
            };
            
            activeTasks.set(taskId, task);
            addTaskMessage('agent', `üöÄ Starting ${taskType} task (ID: ${taskId})...`, agentId);
            
            // Simulate task execution with progress updates
            await simulateTaskExecution(task);
            
            return task;
        }

        async function simulateTaskExecution(task) {
            const { id, agentId, type, parameters } = task;
            
            // Update progress incrementally
            for (let progress = 10; progress <= 100; progress += 10) {
                await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
                task.progress = progress;
                
                if (progress === 30 || progress === 60 || progress === 90) {
                    addProgressMessage(agentId, `Task ${id}: ${progress}% complete`, task);
                }
            }
            
            // Generate realistic results based on task type
            const results = await generateTaskResults(task);
            task.results = results;
            task.status = 'completed';
            task.endTime = new Date();
            
            // Display final results
            displayTaskResults(task);
        }

        async function generateTaskResults(task) {
            const { type, agentId, parameters } = task;
            
            switch (agentId) {
                case 'redteam':
                    return await generatePentestResults(type, parameters);
                case 'threathunter':
                    return await generateThreatHuntResults(type, parameters);
                case 'malware':
                    return await generateMalwareResults(type, parameters);
                case 'incident':
                    return await generateIncidentResults(type, parameters);
                default:
                    return ['Task completed successfully'];
            }
        }

        async function generatePentestResults(type, params) {
            if (!securityPlatform) return ['Security platform not initialized'];

            const realResults = [];
            const networkScan = await securityPlatform.performNetworkScan();

            switch (type) {
                case 'vulnerability_scan':
                    realResults.push('üîç Network vulnerability assessment completed');
                    realResults.push(`‚Ä¢ Target network: ${networkScan.publicIP}`);
                    realResults.push(`‚Ä¢ Location: ${networkScan.location}`);
                    realResults.push(`‚Ä¢ ISP: ${networkScan.isp}`);
                    realResults.push(`‚Ä¢ Open ports detected: ${networkScan.openPorts.join(', ')}`);
                    
                    if (networkScan.securityIssues.length > 0) {
                        realResults.push('üö® Security issues identified:');
                        networkScan.securityIssues.forEach(issue => {
                            realResults.push(`  ‚Ä¢ ${issue}`);
                        });
                    } else {
                        realResults.push('‚úÖ No major vulnerabilities detected');
                    }
                    
                    realResults.push(`üìä Scan completed at ${networkScan.timestamp.toLocaleTimeString()}`);
                    break;

                case 'web_app_test':
                    realResults.push('üåê Web application security assessment');
                    realResults.push(`‚Ä¢ Target: ${window.location.hostname}`);
                    realResults.push(`‚Ä¢ Protocol: ${window.location.protocol}`);
                    realResults.push(`‚Ä¢ HTTPS: ${securityPlatform.securityStatus.https ? 'Enabled ‚úÖ' : 'Disabled ‚ùå'}`);
                    realResults.push(`‚Ä¢ Secure Context: ${securityPlatform.securityStatus.secureContext ? 'Yes ‚úÖ' : 'No ‚ùå'}`);
                    realResults.push(`‚Ä¢ CSP Headers: ${securityPlatform.securityStatus.contentSecurityPolicy ? 'Present ‚úÖ' : 'Missing ‚ùå'}`);
                    realResults.push(`‚Ä¢ HSTS: ${securityPlatform.securityStatus.strictTransportSecurity ? 'Enabled ‚úÖ' : 'Disabled ‚ùå'}`);
                    
                    const issues = securityPlatform.securityStatus.potentialIssues || [];
                    if (issues.length > 0) {
                        realResults.push('‚ö†Ô∏è Issues detected:');
                        issues.forEach(issue => realResults.push(`  ‚Ä¢ ${issue}`));
                    }
                    break;

                case 'network_recon':
                    realResults.push('üî¨ Network reconnaissance completed');
                    realResults.push(`‚Ä¢ Public IP: ${networkScan.publicIP}`);
                    realResults.push(`‚Ä¢ Local IPs: ${networkScan.localIPs.join(', ')}`);
                    realResults.push(`‚Ä¢ Geographic location: ${networkScan.location}`);
                    realResults.push(`‚Ä¢ Internet provider: ${networkScan.isp}`);
                    realResults.push(`‚Ä¢ DNS servers: ${networkScan.dnsServers.join(', ')}`);
                    realResults.push(`‚Ä¢ Accessible ports: ${networkScan.openPorts.join(', ')}`);
                    
                    if (networkScan.threats.length > 0) {
                        realResults.push('üö® Potential threats:');
                        networkScan.threats.forEach(threat => realResults.push(`  ‚Ä¢ ${threat}`));
                    }
                    break;

                case 'sql_injection':
                    realResults.push('üíâ SQL injection assessment');
                    realResults.push(`‚Ä¢ Target: ${window.location.hostname}`);
                    realResults.push('‚Ä¢ Form inputs scanned for injection vulnerabilities');
                    realResults.push('‚Ä¢ Testing parameter validation and sanitization');
                    
                    // Check for potential SQL injection vectors in current page
                    const forms = document.querySelectorAll('form');
                    const inputs = document.querySelectorAll('input[type="text"], input[type="search"], textarea');
                    
                    realResults.push(`‚Ä¢ Forms found: ${forms.length}`);
                    realResults.push(`‚Ä¢ Input fields analyzed: ${inputs.length}`);
                    
                    if (!securityPlatform.securityStatus.https) {
                        realResults.push('üö® Critical: Non-HTTPS connection allows credential interception');
                    }
                    
                    realResults.push('‚Ä¢ Recommendation: Implement parameterized queries and input validation');
                    break;

                case 'wireless_audit':
                    realResults.push('üì° Wireless network security assessment');
                    
                    if (navigator.connection) {
                        realResults.push(`‚Ä¢ Connection type: ${navigator.connection.effectiveType}`);
                        realResults.push(`‚Ä¢ Downlink speed: ${navigator.connection.downlink} Mbps`);
                        realResults.push(`‚Ä¢ Round-trip time: ${navigator.connection.rtt} ms`);
                    }
                    
                    realResults.push('‚Ä¢ Note: Browser security limitations prevent direct WiFi scanning');
                    realResults.push('‚Ä¢ Recommendation: Use dedicated tools for comprehensive wireless audit');
                    break;

                case 'password_test':
                    realResults.push('üîì Authentication security assessment');
                    realResults.push(`‚Ä¢ Browser: ${navigator.userAgent.split(' ')[0]}`);
                    realResults.push(`‚Ä¢ Cookies enabled: ${navigator.cookieEnabled ? 'Yes' : 'No'}`);
                    realResults.push(`‚Ä¢ Do Not Track: ${navigator.doNotTrack || 'Not set'}`);
                    
                    // Check for password managers
                    const passwordFields = document.querySelectorAll('input[type="password"]');
                    realResults.push(`‚Ä¢ Password fields on page: ${passwordFields.length}`);
                    
                    if (!securityPlatform.securityStatus.https) {
                        realResults.push('üö® Critical: Passwords transmitted over unencrypted connection');
                    }
                    
                    realResults.push('‚Ä¢ Recommendation: Enforce strong password policies and MFA');
                    break;

                default:
                    realResults.push('Real-time security assessment completed');
                    realResults.push(`‚Ä¢ Analysis performed on ${new Date().toLocaleString()}`);
            }

            return realResults;
        }

        async function generateThreatHuntResults(type, params) {
            if (!securityPlatform) return ['Security platform not initialized'];

            const realResults = [];
            const networkScan = await securityPlatform.performNetworkScan();
            const stats = await securityPlatform.getRealTimeStats();

            switch (type) {
                case 'ioc_hunt':
                    realResults.push('üéØ IOC hunting analysis completed');
                    realResults.push(`‚Ä¢ Target IP: ${networkScan.publicIP}`);
                    realResults.push(`‚Ä¢ Geolocation: ${networkScan.location}`);
                    realResults.push(`‚Ä¢ ISP: ${networkScan.isp}`);
                    
                    if (networkScan.threats.length > 0) {
                        realResults.push('üö® Threat indicators found:');
                        networkScan.threats.forEach(threat => realResults.push(`  ‚Ä¢ ${threat}`));
                    } else {
                        realResults.push('‚úÖ No known threat indicators detected');
                    }
                    
                    realResults.push(`‚Ä¢ DNS servers: ${networkScan.dnsServers.join(', ')}`);
                    realResults.push(`‚Ä¢ Analysis timestamp: ${new Date().toLocaleString()}`);
                    break;

                case 'behavioral_analysis':
                    realResults.push('üìä Behavioral analysis results');
                    realResults.push(`‚Ä¢ Browser fingerprint: ${navigator.userAgent.split(' ')[0]}`);
                    realResults.push(`‚Ä¢ Platform: ${navigator.platform}`);
                    realResults.push(`‚Ä¢ Language: ${navigator.language}`);
                    realResults.push(`‚Ä¢ Timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}`);
                    
                    if (stats.memoryUsage.used > 0) {
                        realResults.push(`‚Ä¢ Memory usage: ${stats.memoryUsage.used}MB / ${stats.memoryUsage.total}MB`);
                        if (stats.memoryUsage.used / stats.memoryUsage.total > 0.8) {
                            realResults.push('‚ö†Ô∏è High memory usage detected (potential memory leak)');
                        }
                    }
                    
                    const securityIssues = securityPlatform.securityStatus.potentialIssues || [];
                    if (securityIssues.length > 0) {
                        realResults.push('üö® Behavioral anomalies detected:');
                        securityIssues.forEach(issue => realResults.push(`  ‚Ä¢ ${issue}`));
                    } else {
                        realResults.push('‚úÖ Normal behavioral patterns observed');
                    }
                    break;

                case 'log_correlation':
                    realResults.push('üìù Security event correlation analysis');
                    realResults.push(`‚Ä¢ Session start: ${new Date().toLocaleString()}`);
                    realResults.push(`‚Ä¢ Client IP: ${networkScan.publicIP}`);
                    realResults.push(`‚Ä¢ User agent: ${navigator.userAgent}`);
                    realResults.push(`‚Ä¢ Connection type: ${navigator.connection?.effectiveType || 'Unknown'}`);
                    
                    const navigationEntries = performance.getEntriesByType('navigation');
                    if (navigationEntries.length > 0) {
                        const nav = navigationEntries[0];
                        realResults.push(`‚Ä¢ Page load time: ${Math.round(nav.loadEventEnd - nav.loadEventStart)}ms`);
                        realResults.push(`‚Ä¢ DNS lookup: ${Math.round(nav.domainLookupEnd - nav.domainLookupStart)}ms`);
                    }
                    
                    realResults.push(`‚Ä¢ Security score: ${securityPlatform.securityStatus.score || 'Calculating...'}%`);
                    realResults.push('üìà Correlation baseline established');
                    break;

                case 'memory_forensics':
                    realResults.push('üß† Memory forensics analysis');
                    if (stats.memoryUsage.used > 0) {
                        realResults.push(`‚Ä¢ JS Heap used: ${stats.memoryUsage.used}MB`);
                        realResults.push(`‚Ä¢ JS Heap total: ${stats.memoryUsage.total}MB`);
                        realResults.push(`‚Ä¢ JS Heap limit: ${stats.memoryUsage.limit}MB`);
                        
                        const utilization = (stats.memoryUsage.used / stats.memoryUsage.total) * 100;
                        realResults.push(`‚Ä¢ Memory utilization: ${utilization.toFixed(1)}%`);
                        
                        if (utilization > 80) {
                            realResults.push('‚ö†Ô∏è High memory utilization detected');
                        }
                    } else {
                        realResults.push('‚Ä¢ Memory API not available in current context');
                    }
                    
                    realResults.push('‚Ä¢ Note: Browser security limits detailed memory analysis');
                    break;

                case 'network_analysis':
                    realResults.push('üåê Network traffic analysis');
                    realResults.push(`‚Ä¢ Source IP: ${networkScan.publicIP}`);
                    realResults.push(`‚Ä¢ Network location: ${networkScan.location}`);
                    
                    if (navigator.connection) {
                        realResults.push(`‚Ä¢ Connection type: ${navigator.connection.effectiveType}`);
                        realResults.push(`‚Ä¢ Downlink: ${navigator.connection.downlink} Mbps`);
                        realResults.push(`‚Ä¢ RTT: ${navigator.connection.rtt}ms`);
                        realResults.push(`‚Ä¢ Data saver: ${navigator.connection.saveData ? 'Enabled' : 'Disabled'}`);
                    }
                    
                    realResults.push(`‚Ä¢ Secure context: ${window.isSecureContext ? 'Yes' : 'No'}`);
                    realResults.push(`‚Ä¢ Protocol: ${window.location.protocol}`);
                    break;

                case 'realtime_monitoring':
                    realResults.push('‚ö° Real-time threat monitoring activated');
                    realResults.push(`‚Ä¢ Monitoring interval: 30 seconds`);
                    realResults.push(`‚Ä¢ Current security score: ${securityPlatform.securityStatus.score || 'Calculating...'}%`);
                    realResults.push(`‚Ä¢ Active monitoring since: ${new Date().toLocaleTimeString()}`);
                    realResults.push('‚Ä¢ Automated alerting: Enabled');
                    realResults.push('‚Ä¢ Continuous assessment: Active');
                    break;

                case 'threat_intel_lookup':
                    realResults.push('üìã Threat intelligence database query');
                    realResults.push(`‚Ä¢ Queried IP: ${networkScan.publicIP}`);
                    realResults.push(`‚Ä¢ Geographic origin: ${networkScan.location}`);
                    realResults.push(`‚Ä¢ ISP/Organization: ${networkScan.isp}`);
                    
                    if (networkScan.threats.length > 0) {
                        realResults.push('üö® Threat intelligence matches:');
                        networkScan.threats.forEach(threat => realResults.push(`  ‚Ä¢ ${threat}`));
                    } else {
                        realResults.push('‚úÖ No threat intelligence matches found');
                    }
                    
                    realResults.push('‚Ä¢ Sources checked: Public threat feeds');
                    break;

                default:
                    realResults.push('Real-time threat hunting completed');
                    realResults.push(`‚Ä¢ Analysis performed: ${new Date().toLocaleString()}`);
            }

            return realResults;
        }

        async function generateMalwareResults(type, params) {
            if (!securityPlatform) return ['Security platform not initialized'];

            const realResults = [];
            const stats = await securityPlatform.getRealTimeStats();
            const networkScan = await securityPlatform.performNetworkScan();

            switch (type) {
                case 'file_analysis':
                    realResults.push('ü¶† File analysis and scanning capabilities');
                    realResults.push(`‚Ä¢ Analysis timestamp: ${new Date().toLocaleString()}`);
                    realResults.push(`‚Ä¢ Client environment: ${navigator.platform}`);
                    realResults.push(`‚Ä¢ Browser context: ${navigator.userAgent.split(' ')[0]}`);
                    realResults.push('‚Ä¢ Note: Direct file analysis requires file upload API integration');
                    realResults.push('‚Ä¢ Security context: File System Access API availability check');
                    
                    if ('showOpenFilePicker' in window) {
                        realResults.push('‚úÖ File System Access API available for secure file handling');
                    } else {
                        realResults.push('‚ö†Ô∏è File System Access API not available - using fallback methods');
                    }
                    
                    realResults.push('‚Ä¢ Recommendation: Integrate with VirusTotal API for comprehensive analysis');
                    break;

                case 'sandbox_execution':
                    realResults.push('üî¨ Sandbox environment analysis');
                    realResults.push(`‚Ä¢ Execution environment: Browser sandbox`);
                    realResults.push(`‚Ä¢ JavaScript heap: ${stats.memoryUsage.used}MB used`);
                    realResults.push(`‚Ä¢ Origin: ${window.location.origin}`);
                    realResults.push(`‚Ä¢ Secure context: ${window.isSecureContext ? 'Yes' : 'No'}`);
                    
                    // Check for potential execution indicators
                    const scripts = document.querySelectorAll('script');
                    const iframes = document.querySelectorAll('iframe');
                    realResults.push(`‚Ä¢ Scripts loaded: ${scripts.length}`);
                    realResults.push(`‚Ä¢ Embedded frames: ${iframes.length}`);
                    
                    if (window.Worker) {
                        realResults.push('‚úÖ Web Workers available for isolated execution');
                    }
                    
                    realResults.push('‚Ä¢ Browser provides natural sandboxing for JavaScript execution');
                    break;

                case 'signature_creation':
                    realResults.push('üìù Signature and rule generation');
                    realResults.push(`‚Ä¢ Target environment: ${window.location.hostname}`);
                    realResults.push(`‚Ä¢ Protocol analysis: ${window.location.protocol}`);
                    realResults.push(`‚Ä¢ User agent fingerprint: ${navigator.userAgent}`);
                    
                    // Generate basic signatures based on environment
                    const securityHeaders = [];
                    if (securityPlatform.securityStatus.https) securityHeaders.push('HTTPS');
                    if (securityPlatform.securityStatus.contentSecurityPolicy) securityHeaders.push('CSP');
                    if (securityPlatform.securityStatus.strictTransportSecurity) securityHeaders.push('HSTS');
                    
                    realResults.push(`‚Ä¢ Security headers detected: ${securityHeaders.join(', ')}`);
                    realResults.push('‚Ä¢ IOC extraction: Network and browser fingerprints collected');
                    realResults.push('‚Ä¢ Rule template: Browser-based detection patterns available');
                    break;

                case 'ransomware_analysis':
                    realResults.push('üè¥‚Äç‚ò†Ô∏è Ransomware behavior analysis');
                    realResults.push(`‚Ä¢ File system access: ${('showOpenFilePicker' in window) ? 'Available' : 'Restricted'}`);
                    realResults.push(`‚Ä¢ Local storage usage: ${JSON.stringify(localStorage).length} bytes`);
                    realResults.push(`‚Ä¢ Session storage usage: ${JSON.stringify(sessionStorage).length} bytes`);
                    
                    // Check for potential ransomware indicators
                    if (navigator.storage && navigator.storage.estimate) {
                        const storage = await navigator.storage.estimate();
                        realResults.push(`‚Ä¢ Storage quota: ${Math.round(storage.quota / 1024 / 1024)}MB`);
                        realResults.push(`‚Ä¢ Storage used: ${Math.round(storage.usage / 1024 / 1024)}MB`);
                    }
                    
                    realResults.push('‚Ä¢ Browser sandbox prevents traditional ransomware execution');
                    realResults.push('‚Ä¢ Monitoring for suspicious storage access patterns');
                    break;

                case 'reverse_engineering':
                    realResults.push('üîç Reverse engineering analysis');
                    realResults.push(`‚Ä¢ Target: Current web application`);
                    realResults.push(`‚Ä¢ JavaScript analysis: ${document.querySelectorAll('script').length} scripts`);
                    realResults.push(`‚Ä¢ External resources: ${document.querySelectorAll('link').length} links`);
                    
                    // Analyze page structure
                    const forms = document.querySelectorAll('form');
                    const inputs = document.querySelectorAll('input');
                    realResults.push(`‚Ä¢ Form elements: ${forms.length} forms, ${inputs.length} inputs`);
                    
                    realResults.push('‚Ä¢ Source code: Available via DevTools inspection');
                    realResults.push('‚Ä¢ Network analysis: Monitor via browser DevTools Network tab');
                    break;

                case 'c2_analysis':
                    realResults.push('üåê Command & Control communication analysis');
                    realResults.push(`‚Ä¢ Origin server: ${window.location.hostname}`);
                    realResults.push(`‚Ä¢ Connection: ${networkScan.publicIP}`);
                    realResults.push(`‚Ä¢ Location: ${networkScan.location}`);
                    realResults.push(`‚Ä¢ ISP: ${networkScan.isp}`);
                    
                    if (navigator.connection) {
                        realResults.push(`‚Ä¢ Network type: ${navigator.connection.effectiveType}`);
                        realResults.push(`‚Ä¢ Downlink: ${navigator.connection.downlink} Mbps`);
                    }
                    
                    realResults.push('‚Ä¢ WebSocket connections: Monitor for persistent channels');
                    realResults.push('‚Ä¢ HTTPS verification: Ensures encrypted C2 communications');
                    break;

                case 'family_classification':
                    realResults.push('üìä Malware family classification');
                    realResults.push(`‚Ä¢ Environment: Web-based application`);
                    realResults.push(`‚Ä¢ Platform: ${navigator.platform}`);
                    realResults.push(`‚Ä¢ Browser: ${navigator.userAgent.split(' ')[0]}`);
                    realResults.push(`‚Ä¢ Language: ${navigator.language}`);
                    
                    realResults.push('‚Ä¢ Classification: Browser-based application');
                    realResults.push('‚Ä¢ Risk level: Low (sandboxed environment)');
                    realResults.push('‚Ä¢ Behavior: Standard web application patterns');
                    break;

                case 'analysis_report':
                    realResults.push('üìã Comprehensive malware analysis report');
                    realResults.push(`‚Ä¢ Report generated: ${new Date().toLocaleString()}`);
                    realResults.push(`‚Ä¢ Analysis target: ${window.location.hostname}`);
                    realResults.push(`‚Ä¢ Security score: ${securityPlatform.securityStatus.score || 'Calculating...'}%`);
                    realResults.push(`‚Ä¢ Threats detected: ${networkScan.threats.length}`);
                    realResults.push(`‚Ä¢ Security issues: ${securityPlatform.securityStatus.potentialIssues?.length || 0}`);
                    realResults.push('‚Ä¢ Report format: JSON/PDF export available');
                    realResults.push('‚Ä¢ Distribution: Secure encrypted transmission');
                    break;

                default:
                    realResults.push('Real-time malware analysis completed');
                    realResults.push(`‚Ä¢ Analysis performed: ${new Date().toLocaleString()}`);
            }

            return realResults;
        }

        async function generateIncidentResults(type, params) {
            if (!securityPlatform) return ['Security platform not initialized'];

            const realResults = [];
            const stats = await securityPlatform.getRealTimeStats();
            const networkScan = await securityPlatform.performNetworkScan();

            switch (type) {
                case 'incident_response':
                    realResults.push('üö® Incident response protocol activated');
                    realResults.push(`‚Ä¢ Incident timestamp: ${new Date().toLocaleString()}`);
                    realResults.push(`‚Ä¢ Response location: ${networkScan.location}`);
                    realResults.push(`‚Ä¢ Affected IP: ${networkScan.publicIP}`);
                    realResults.push(`‚Ä¢ Security score: ${securityPlatform.securityStatus.score || 'Calculating...'}%`);
                    
                    const issueCount = securityPlatform.securityStatus.potentialIssues?.length || 0;
                    if (issueCount > 0) {
                        realResults.push(`‚Ä¢ Security issues identified: ${issueCount}`);
                        realResults.push('‚Ä¢ Containment: Monitoring active threats');
                        securityPlatform.securityStatus.potentialIssues.forEach(issue => {
                            realResults.push(`  - ${issue}`);
                        });
                    } else {
                        realResults.push('‚Ä¢ Status: No active security incidents detected');
                    }
                    
                    realResults.push(`‚Ä¢ Response team: Automated systems monitoring`);
                    realResults.push(`‚Ä¢ Communication: Secure channel established`);
                    break;

                case 'forensic_analysis':
                    realResults.push('üîç Digital forensics investigation');
                    realResults.push(`‚Ä¢ Investigation start: ${new Date().toLocaleString()}`);
                    realResults.push(`‚Ä¢ Evidence source: ${window.location.hostname}`);
                    realResults.push(`‚Ä¢ Client fingerprint: ${navigator.userAgent}`);
                    realResults.push(`‚Ä¢ Connection details: ${networkScan.publicIP} (${networkScan.location})`);
                    
                    // Collect forensic data
                    const navigationEntries = performance.getEntriesByType('navigation');
                    if (navigationEntries.length > 0) {
                        const nav = navigationEntries[0];
                        realResults.push(`‚Ä¢ Page load forensics: ${Math.round(nav.loadEventEnd - nav.loadEventStart)}ms`);
                        realResults.push(`‚Ä¢ DNS resolution: ${Math.round(nav.domainLookupEnd - nav.domainLookupStart)}ms`);
                        realResults.push(`‚Ä¢ Connection time: ${Math.round(nav.connectEnd - nav.connectStart)}ms`);
                    }
                    
                    realResults.push(`‚Ä¢ Browser storage: ${JSON.stringify(localStorage).length} bytes local`);
                    realResults.push(`‚Ä¢ Session data: ${JSON.stringify(sessionStorage).length} bytes session`);
                    realResults.push('‚Ä¢ Chain of custody: Cryptographic timestamps maintained');
                    break;

                case 'recovery_planning':
                    realResults.push('üîß Recovery and business continuity plan');
                    realResults.push(`‚Ä¢ Recovery initiated: ${new Date().toLocaleString()}`);
                    realResults.push(`‚Ä¢ System status: ${securityPlatform.securityStatus.score || 'Assessing...'}% operational`);
                    realResults.push(`‚Ä¢ Network connectivity: ${navigator.connection?.effectiveType || 'Unknown'}`);
                    
                    if (stats.memoryUsage.used > 0) {
                        const memoryHealth = (stats.memoryUsage.used / stats.memoryUsage.total) * 100;
                        realResults.push(`‚Ä¢ Memory utilization: ${memoryHealth.toFixed(1)}%`);
                        if (memoryHealth < 80) {
                            realResults.push('‚úÖ System resources: Healthy');
                        } else {
                            realResults.push('‚ö†Ô∏è System resources: High utilization');
                        }
                    }
                    
                    realResults.push(`‚Ä¢ Security monitoring: Active (${securityPlatform.securityStatus.lastUpdate || 'Real-time'})`);
                    realResults.push('‚Ä¢ Backup verification: Cloud-based recovery options available');
                    realResults.push('‚Ä¢ Communication: Incident response team notified');
                    break;

                default:
                    realResults.push('Real-time incident response completed');
                    realResults.push(`‚Ä¢ Response performed: ${new Date().toLocaleString()}`);
            }

            return realResults;
        }

        function addTaskMessage(type, text, agentId) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type} task-message`;
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            
            if (type === 'agent') {
                const agent = agents[agentId];
                avatarDiv.innerHTML = `<span class="icon icon-${agent?.icon || 'robot'}"></span>`;
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content task-content';
            contentDiv.innerHTML = `<div class="task-header">${text}</div>`;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            const now = new Date();
            timeDiv.textContent = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
            
            contentDiv.appendChild(timeDiv);
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function addProgressMessage(agentId, text, task) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message agent progress-message';
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            const agent = agents[agentId];
            avatarDiv.innerHTML = `<span class="icon icon-${agent?.icon || 'robot'}"></span>`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const progressDiv = document.createElement('div');
            progressDiv.className = 'task-progress';
            progressDiv.innerHTML = `
                <div class="progress-text">${text}</div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${task.progress}%"></div>
                </div>
            `;
            
            contentDiv.appendChild(progressDiv);
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function displayTaskResults(task) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message agent results-message';
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            const agent = agents[task.agentId];
            avatarDiv.innerHTML = `<span class="icon icon-${agent?.icon || 'robot'}"></span>`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content results-content';
            
            const resultsDiv = document.createElement('div');
            resultsDiv.className = 'task-results';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'results-header';
            headerDiv.innerHTML = `‚úÖ Task ${task.id} completed successfully`;
            
            const resultsListDiv = document.createElement('div');
            resultsListDiv.className = 'results-list';
            task.results.forEach(result => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                resultItem.textContent = result;
                resultsListDiv.appendChild(resultItem);
            });
            
            const actionDiv = document.createElement('div');
            actionDiv.className = 'task-actions';
            actionDiv.innerHTML = `
                <button class="task-action-btn" onclick="exportResults('${task.id}')">üìä Export Report</button>
                <button class="task-action-btn" onclick="scheduleFollowUp('${task.id}')">üìÖ Schedule Follow-up</button>
            `;
            
            resultsDiv.appendChild(headerDiv);
            resultsDiv.appendChild(resultsListDiv);
            resultsDiv.appendChild(actionDiv);
            contentDiv.appendChild(resultsDiv);
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            const duration = task.endTime - task.startTime;
            timeDiv.textContent = `Completed in ${Math.round(duration / 1000)}s`;
            
            contentDiv.appendChild(timeDiv);
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function exportResults(taskId) {
            const task = activeTasks.get(taskId);
            if (task) {
                showNotification(`üìä Exporting results for task ${taskId}...`, 'info');
                setTimeout(() => {
                    showNotification('‚úÖ Report exported successfully to /reports/' + taskId + '.json', 'success');
                }, 2000);
            }
        }

        function scheduleFollowUp(taskId) {
            const task = activeTasks.get(taskId);
            if (task) {
                showNotification(`üìÖ Follow-up scheduled for task ${taskId}`, 'success');
            }
        }

        // Dropdown functionality
        function populateTaskDropdown(agentId) {
            const dropdown = document.getElementById('taskDropdown');
            if (!dropdown) return;
            
            // Clear existing options
            dropdown.innerHTML = '<option value="">Select a security task or tool...</option>';
            
            // Get tasks for the specific agent
            const tasks = agentTaskPrompts[agentId] || [];
            
            // Populate dropdown with agent-specific tasks and tools
            tasks.forEach(task => {
                const option = document.createElement('option');
                option.value = task.prompt;
                option.textContent = task.name;
                option.title = task.description; // Tooltip with description
                
                // Handle disabled sections (headers)
                if (task.disabled) {
                    option.disabled = true;
                    option.style.fontWeight = 'bold';
                    option.style.color = '#888';
                    option.style.backgroundColor = '#2a2a2a';
                }
                
                dropdown.appendChild(option);
            });
        }

        function executeSelectedTask() {
            const dropdown = document.getElementById('taskDropdown');
            const chatInput = document.getElementById('chatInput');
            
            if (!dropdown || !chatInput) return;
            
            const selectedTask = dropdown.value;
            if (selectedTask && selectedTask.trim() !== '') {
                // Set the input value
                chatInput.value = selectedTask;
                
                // Auto-resize the textarea
                chatInput.style.height = 'auto';
                chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
                
                // Auto-send the message
                sendMessage();
                
                // Reset dropdown after a short delay to prevent flicker
                setTimeout(() => {
                    dropdown.selectedIndex = 0;
                }, 100);
            }
        }

        // Enhanced dropdown with search functionality
        function filterTasks() {
            const dropdown = document.getElementById('taskDropdown');
            const searchTerm = dropdown.getAttribute('data-search') || '';
            
            if (!searchTerm) return;
            
            const options = dropdown.querySelectorAll('option');
            options.forEach(option => {
                if (option.value === '') return; // Keep the placeholder
                
                const matchesSearch = option.textContent.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                    option.title.toLowerCase().includes(searchTerm.toLowerCase());
                option.style.display = matchesSearch ? 'block' : 'none';
            });
        }

        // Navigation functionality
        function navigateToSection(section) {
            console.log('Navigating to section:', section);
            
            // Remove active class from all nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });

            // Add active class to clicked nav link
            const activeLink = document.querySelector(`[data-section="${section}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
            }

            // Hide all content sections
            document.querySelectorAll('.content-section').forEach(content => {
                content.classList.remove('active');
            });

            // Show selected content section
            const targetSection = document.getElementById(`${section}-content`);
            if (targetSection) {
                targetSection.classList.add('active');
            } else {
                console.warn(`Section ${section}-content not found`);
                // Fallback to dashboard if section doesn't exist
                const dashboardSection = document.getElementById('dashboard-content');
                const dashboardNav = document.querySelector('[data-section="dashboard"]');
                if (dashboardSection) dashboardSection.classList.add('active');
                if (dashboardNav) dashboardNav.classList.add('active');
                section = 'dashboard';
            }

            // Update page title
            const titles = {
                dashboard: 'Security Dashboard',
                agents: 'AI Security Agents',
                identity: 'Identity Management',
                endpoints: 'Device Management',
                users: 'User Access Control',
                network: 'Network Security',
                compliance: 'Compliance & Auditing'
            };
            const titleElement = document.getElementById('page-title');
            if (titleElement) {
                titleElement.textContent = titles[section] || 'Security Dashboard';
            }
        }

        // Notification system
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            const notificationText = document.getElementById('notification-text');
            
            if (!notification || !notificationText) return;
            
            notificationText.textContent = message;
            
            const icon = notification.querySelector('.icon');
            if (icon) {
                icon.className = 'icon ' + (type === 'success' ? 'icon-check' : 
                               type === 'error' ? 'icon-times' : 
                               'icon-info');
            }
            
            if (type === 'error') {
                notification.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
            } else if (type === 'info') {
                notification.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
            } else {
                notification.style.background = 'linear-gradient(135deg, #10b981, #059669)';
            }
            
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }

        // Chat functionality
        function openAgentChat(agentId) {
            const agent = agents[agentId] || {
                name: 'AI Agent',
                role: 'Cybersecurity Specialist',
                icon: 'robot'
            };
            
            const chatModal = document.getElementById('chatModal');
            const chatAgentName = document.getElementById('chatAgentName');
            const chatAgentRole = document.getElementById('chatAgentRole');
            const chatAgentAvatar = document.getElementById('chatAgentAvatar');
            const chatMessages = document.getElementById('chatMessages');
            const chatSuggestions = document.getElementById('chatSuggestions');
            
            if (chatModal) chatModal.classList.add('active');
            if (chatAgentName) chatAgentName.textContent = agent.name;
            if (chatAgentRole) chatAgentRole.textContent = agent.role;
            if (chatAgentAvatar) {
                chatAgentAvatar.innerHTML = `<span class="icon icon-${agent.icon}"></span>`;
            }
            
            // Clear previous messages
            if (chatMessages) chatMessages.innerHTML = '';
            
            // Add welcome message
            addMessage('agent', `Hello, I'm ${agent.name}, your ${agent.role.toLowerCase()}. How can I help you today?`, agentId);
            
            // Populate task dropdown for this agent
            populateTaskDropdown(agentId);
            
            // Remove chat suggestions - moved to dropdown only
            if (chatSuggestions) {
                chatSuggestions.innerHTML = '';
            }
            
            // Focus on input
            setTimeout(() => {
                const chatInput = document.getElementById('chatInput');
                if (chatInput) chatInput.focus();
            }, 300);
        }

        function closeChatModal() {
            const chatModal = document.getElementById('chatModal');
            if (chatModal) chatModal.classList.remove('active');
        }

        // Network Devices Modal Functions
        async function showNetworkDevices() {
            const modal = document.getElementById('networkDevicesModal');
            const devicesList = document.getElementById('networkDevicesList');
            
            if (modal) modal.classList.add('active');
            
            // Show scanning indicator
            devicesList.innerHTML = `
                <div class="device-scanning">
                    <div class="scanning-indicator">
                        <span class="icon icon-spinner"></span>
                    </div>
                    <p>Scanning network for devices...</p>
                </div>
            `;
            
            try {
                // Get network scan results
                const networkScan = await securityPlatform.performNetworkScan();
                const devices = networkScan.networkDevices || [];
                
                // Display devices
                devicesList.innerHTML = '';
                
                if (devices.length === 0) {
                    devicesList.innerHTML = `
                        <div class="device-item">
                            <div class="device-info">
                                <strong>No devices discovered</strong>
                                <p>Unable to discover network devices due to browser security limitations.</p>
                            </div>
                        </div>
                    `;
                } else {
                    devices.forEach(device => {
                        const deviceItem = document.createElement('div');
                        deviceItem.className = 'device-item';
                        
                        const statusClass = device.status === 'online' ? 'online' : 'detected';
                        const deviceIcon = getDeviceIcon(device.type);
                        
                        deviceItem.innerHTML = `
                            <div class="device-icon">
                                <span class="icon ${deviceIcon}"></span>
                            </div>
                            <div class="device-info">
                                <div class="device-name">${device.hostname}</div>
                                <div class="device-details">
                                    <span class="device-ip">${device.ip}</span>
                                    <span class="device-status ${statusClass}">${device.status}</span>
                                </div>
                                <div class="device-meta">
                                    <span>Type: ${device.type}</span>
                                    <span>Last seen: ${device.lastSeen.toLocaleTimeString()}</span>
                                </div>
                            </div>
                        `;
                        
                        devicesList.appendChild(deviceItem);
                    });
                }
                
            } catch (error) {
                console.error('Network scanning error:', error);
                devicesList.innerHTML = `
                    <div class="device-item">
                        <div class="device-info">
                            <strong>Scanning Error</strong>
                            <p>Unable to complete network device discovery: ${error.message}</p>
                        </div>
                    </div>
                `;
            }
        }

        function closeNetworkDevicesModal() {
            const modal = document.getElementById('networkDevicesModal');
            if (modal) modal.classList.remove('active');
        }

        function getDeviceIcon(deviceType) {
            switch (deviceType) {
                case 'router': return 'icon-network';
                case 'computer': return 'icon-desktop';
                case 'mobile': return 'icon-mobile';
                case 'tablet': return 'icon-tablet';
                case 'iot': return 'icon-lightbulb';
                case 'server': return 'icon-server';
                case 'printer': return 'icon-print';
                case 'camera': return 'icon-camera';
                case 'tv': return 'icon-tv';
                default: return 'icon-desktop';
            }
        }

        function addMessage(type, text, agentId = null) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            
            if (type === 'agent') {
                const agent = agentId ? agents[agentId] : { icon: 'robot' };
                avatarDiv.innerHTML = `<span class="icon icon-${agent?.icon || 'robot'}"></span>`;
            } else {
                avatarDiv.innerHTML = '<span class="icon icon-user"></span>';
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = text;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            const now = new Date();
            timeDiv.textContent = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
            
            contentDiv.appendChild(timeDiv);
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function addTypingIndicator() {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const existingIndicator = chatMessages.querySelector('.typing-indicator-container');
            if (existingIndicator) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message agent typing-indicator-container';
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            avatarDiv.innerHTML = '<span class="icon icon-robot"></span>';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const typingDiv = document.createElement('div');
            typingDiv.className = 'typing-indicator';
            typingDiv.innerHTML = '<span></span><span></span><span></span>';
            
            contentDiv.appendChild(typingDiv);
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function removeTypingIndicator() {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const indicator = chatMessages.querySelector('.typing-indicator-container');
            if (indicator) {
                indicator.remove();
            }
        }

        function getCurrentAgentId() {
            const chatAgentName = document.getElementById('chatAgentName');
            if (!chatAgentName) return null;
            
            const agentName = chatAgentName.textContent;
            for (const [id, agent] of Object.entries(agents)) {
                if (agent.name === agentName) {
                    return id;
                }
            }
            return null;
        }

        function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            if (!chatInput || !chatInput.value.trim()) return;
            
            const message = chatInput.value.trim();
            const agentId = getCurrentAgentId();
            
            // Add user message
            addMessage('user', message);
            
            // Clear input
            chatInput.value = '';
            chatInput.style.height = 'auto';
            
            // Show typing indicator
            addTypingIndicator();
            
            // Generate Claude-like responses based on agent type
            let response = '';
            const agent = agents[agentId] || {
                name: 'AI Agent',
                role: 'Cybersecurity Specialist'
            };
            
            // Check for automation commands and execute tasks
            let shouldExecuteTask = false;
            let taskType = '';
            let taskParams = {};

            if (agentId === 'redteam') {
                if (message.includes('vulnerability') && message.includes('scan')) {
                    response = "I'll help you conduct a comprehensive vulnerability assessment. Let me analyze your network infrastructure to identify potential security weaknesses, misconfigurations, and known vulnerabilities that could be exploited by attackers.";
                    shouldExecuteTask = true;
                    taskType = 'vulnerability_scan';
                    taskParams = { target: message.match(/(\d+\.\d+\.\d+\.\d+\/?\d*)/)?.[0] || 'default_network' };
                } else if (message.includes('web') && (message.includes('application') || message.includes('test'))) {
                    response = "I'll perform a thorough web application security assessment, testing for the OWASP Top 10 vulnerabilities including injection flaws, broken authentication, and cross-site scripting. This will help identify potential entry points for attackers.";
                    shouldExecuteTask = true;
                    taskType = 'web_app_test';
                } else if (message.includes('network') && message.includes('reconnaissance')) {
                    response = "I'll conduct detailed network reconnaissance to map your infrastructure. This involves discovering live hosts, identifying open ports and services, and understanding your network topology - essentially seeing what an attacker would see during initial reconnaissance.";
                    shouldExecuteTask = true;
                    taskType = 'network_recon';
                } else if (message.includes('SQL') && message.includes('injection')) {
                    response = "I'll test your applications for SQL injection vulnerabilities by analyzing input fields and parameters that interact with databases. This is crucial since SQL injection remains one of the most critical web application vulnerabilities.";
                    shouldExecuteTask = true;
                    taskType = 'sql_injection';
                } else if (message.includes('wireless') && message.includes('security')) {
                    response = "I'll assess your wireless network security by evaluating Wi-Fi encryption protocols, identifying rogue access points, and checking for common misconfigurations that could allow unauthorized network access.";
                    shouldExecuteTask = true;
                    taskType = 'wireless_audit';
                } else if (message.includes('password') && (message.includes('policies') || message.includes('brute'))) {
                    response = "I'll evaluate your password security by testing password strength, analyzing authentication mechanisms, and assessing password policies. This helps identify weak credentials that could be compromised through brute force attacks.";
                    shouldExecuteTask = true;
                    taskType = 'password_test';
                } else if (message.includes('social engineering')) {
                    response = "I'll assess your organization's susceptibility to social engineering attacks by evaluating security awareness and human factor vulnerabilities. This includes testing how well your team can identify and respond to phishing attempts and other social engineering tactics.";
                    shouldExecuteTask = true;
                    taskType = 'social_engineering';
                } else if (message.includes('tools') && message.includes('capabilities')) {
                    response = `I'm equipped with a comprehensive arsenal of penetration testing tools and techniques. Here's what I bring to your security assessment:\n\n**Core Tools:** Nmap for network discovery, Metasploit for exploitation, Burp Suite for web testing, Nikto for web scanning, SQLmap for database testing, and many others.\n\n**What I can help you with:**\n‚Ä¢ Network infrastructure security assessments\n‚Ä¢ Web application vulnerability testing\n‚Ä¢ Wireless network security audits\n‚Ä¢ Social engineering assessments\n‚Ä¢ Password policy and authentication testing\n‚Ä¢ Post-exploitation and privilege escalation testing\n\nI approach each assessment methodically, starting with reconnaissance and progressing through vulnerability identification, exploitation attempts (where safe), and detailed reporting with remediation guidance. What would you like to focus on first?`;
                } else {
                    response = "I'm your penetration testing specialist, and I take a methodical approach to identifying security vulnerabilities through ethical hacking. Think of me as your friendly adversary - I'll attack your systems the same way a malicious actor would, but with the goal of helping you strengthen your defenses.\n\nI can help you with everything from basic network scans to complex multi-stage attacks, always ensuring we stay within safe boundaries and provide actionable remediation advice. What aspect of your security posture would you like me to examine?";
                }
            } else if (agentId === 'threathunter') {
                if (message.includes('IOC') || (message.includes('hunt') && message.includes('indicators'))) {
                    response = "I'll search for indicators of compromise across your environment. This involves analyzing network traffic, system logs, and behavioral patterns to identify signs of active threats or past intrusions that might have gone undetected.";
                    shouldExecuteTask = true;
                    taskType = 'ioc_hunt';
                } else if (message.includes('behavioral') || (message.includes('suspicious') && message.includes('activity'))) {
                    response = "I'll analyze behavioral patterns to identify anomalies that could indicate threats. This includes examining user activities, system processes, and network communications for deviations from normal baselines that might suggest compromise.";
                    shouldExecuteTask = true;
                    taskType = 'behavioral_analysis';
                } else if (message.includes('correlate') && message.includes('logs')) {
                    response = "I'll correlate security events from multiple sources to identify patterns and potential threats. By analyzing logs from firewalls, intrusion detection systems, and endpoint security tools, I can help connect the dots between seemingly unrelated events.";
                    shouldExecuteTask = true;
                    taskType = 'log_correlation';
                } else if (message.includes('memory') && message.includes('analysis')) {
                    response = "I'll perform memory forensics to identify hidden threats and artifacts that might not be visible through traditional monitoring. This deep analysis can reveal advanced persistent threats and sophisticated malware designed to evade detection.";
                    shouldExecuteTask = true;
                    taskType = 'memory_forensics';
                } else if (message.includes('network traffic') && message.includes('analysis')) {
                    response = "I'll analyze network traffic patterns to identify suspicious communications and potential threats. This includes examining data flows, identifying command and control channels, and detecting data exfiltration attempts.";
                    shouldExecuteTask = true;
                    taskType = 'network_analysis';
                } else if (message.includes('real-time') && message.includes('threats')) {
                    response = "I'll establish real-time threat monitoring to continuously watch for emerging threats and trigger automated responses. This proactive approach helps minimize dwell time and reduces the impact of security incidents.";
                    shouldExecuteTask = true;
                    taskType = 'realtime_monitoring';
                } else if (message.includes('threat intelligence')) {
                    response = "I'll query threat intelligence databases to validate indicators against global threat feeds. This helps contextualize potential threats and provides actionable intelligence for your security team.";
                    shouldExecuteTask = true;
                    taskType = 'threat_intel_lookup';
                } else if (message.includes('tools') && message.includes('capabilities')) {
                    response = `I'm your advanced threat hunting specialist, equipped with cutting-edge detection and analysis capabilities. Here's what makes me effective:\n\n**Hunting Arsenal:** Wireshark for deep packet analysis, Sigma rules for threat detection, YARA for pattern matching, Osquery for system interrogation, Suricata for network monitoring, and advanced SIEM correlation engines.\n\n**My hunting methodology:**\n‚Ä¢ Hypothesis-driven threat hunting based on TTPs\n‚Ä¢ Behavioral analysis to identify anomalous activities\n‚Ä¢ IOC and threat intelligence correlation\n‚Ä¢ Memory forensics for rootkit and advanced malware detection\n‚Ä¢ Network traffic analysis for command and control detection\n‚Ä¢ Log analysis and event correlation across multiple data sources\n\nI think like an attacker but work for the defenders. I look for the subtle signs that automated tools often miss - the slight anomalies in user behavior, the unusual network patterns, the traces left by sophisticated adversaries. What suspicious activity or potential threats should we investigate together?`;
                } else {
                    response = "I'm your proactive threat hunter, and I approach cybersecurity like a detective solving a complex case. While traditional security tools wait for known signatures and patterns, I actively search for the unknown - the sophisticated adversaries who are trying to stay hidden in your environment.\n\nI excel at connecting seemingly unrelated events, identifying subtle behavioral anomalies, and uncovering the breadcrumbs that advanced threats inevitably leave behind. Whether it's a nation-state actor, insider threat, or advanced persistent threat, I'll help you find them before they achieve their objectives. What indicators or suspicious activities have caught your attention?";
                }
            } else if (agentId === 'malware') {
                if (message.includes('analyze') && message.includes('file')) {
                    response = "I'll perform comprehensive malware analysis on your suspicious file. This includes static analysis to examine the file structure and code, as well as dynamic analysis to understand its behavior when executed in a controlled environment.";
                    shouldExecuteTask = true;
                    taskType = 'file_analysis';
                } else if (message.includes('sandbox') && message.includes('execution')) {
                    response = "I'll execute the sample in a secure sandbox environment to observe its behavior safely. This allows us to understand what the malware does without risking your production systems, including network communications, file modifications, and system changes.";
                    shouldExecuteTask = true;
                    taskType = 'sandbox_execution';
                } else if (message.includes('YARA') || message.includes('signature')) {
                    response = "I'll create detection signatures and YARA rules based on the malware's characteristics. These signatures can then be deployed to your security tools to automatically detect similar threats in the future.";
                    shouldExecuteTask = true;
                    taskType = 'signature_creation';
                } else if (message.includes('ransomware') && message.includes('indicators')) {
                    response = "I'll analyze for ransomware indicators including encryption behaviors, ransom note patterns, and command and control communications. This specialized analysis helps identify and respond to ransomware threats quickly.";
                    shouldExecuteTask = true;
                    taskType = 'ransomware_analysis';
                } else if (message.includes('reverse engineering')) {
                    response = "I'll perform reverse engineering analysis to understand the malware's inner workings. This involves disassembling the code, analyzing its functions, and understanding how it operates to better defend against it.";
                    shouldExecuteTask = true;
                    taskType = 'reverse_engineering';
                } else if (message.includes('C2') || message.includes('command and control')) {
                    response = "I'll analyze command and control communications to understand how the malware communicates with its operators. This includes identifying C2 servers, communication protocols, and data being transmitted.";
                    shouldExecuteTask = true;
                    taskType = 'c2_analysis';
                } else if (message.includes('family classification')) {
                    response = "I'll classify the malware family and identify variants to help with attribution and threat intelligence. This analysis helps understand the threat actor's capabilities and potential future attacks.";
                    shouldExecuteTask = true;
                    taskType = 'family_classification';
                } else if (message.includes('analysis report')) {
                    response = "I'll compile a comprehensive analysis report documenting all findings, including technical details, indicators of compromise, and recommended countermeasures. This report will be suitable for sharing with your security team and stakeholders.";
                    shouldExecuteTask = true;
                    taskType = 'analysis_report';
                } else if (message.includes('tools') && message.includes('capabilities')) {
                    response = `I'm your malware analysis specialist, armed with the most advanced tools for dissecting and understanding malicious software. Here's my analytical toolkit:\n\n**Reverse Engineering Arsenal:** Ghidra for deep code analysis, IDA Pro for disassembly, Volatility for memory forensics, Cuckoo for dynamic analysis, VirusTotal for multi-engine scanning, and custom sandboxes for safe execution.\n\n**My analysis approach:**\n‚Ä¢ Static analysis to examine code structure without execution\n‚Ä¢ Dynamic analysis in controlled sandbox environments\n‚Ä¢ Memory forensics to understand runtime behavior\n‚Ä¢ Network analysis to map command and control infrastructure\n‚Ä¢ Signature creation for detection and prevention\n‚Ä¢ Family classification and threat attribution\n‚Ä¢ Reverse engineering to understand attack mechanisms\n\nI treat each malware sample like a puzzle to be solved. I'll dissect its code, understand its intentions, trace its communications, and help you build defenses against it and similar threats. Whether it's ransomware, banking trojans, or nation-state malware, I'll help you understand what you're dealing with. What suspicious file or behavior has caught your attention?`;
                } else {
                    response = "I'm your malware analysis specialist, and I find malicious software fascinating from a technical perspective - not because I want to cause harm, but because understanding how these threats work is crucial for defending against them.\n\nI approach each sample methodically, like a scientist studying a new organism. I'll examine its code, watch how it behaves, understand its communication patterns, and help you develop targeted defenses. My goal is to give you deep insights into what the malware is trying to accomplish and how to stop it effectively.\n\nWhether you have a suspicious file, unusual system behavior, or want to understand a specific malware family, I'm here to help dissect and analyze it safely. What would you like to investigate?";
                }
            } else if (agentId === 'incident') {
                if (message.includes('incident') && message.includes('response')) {
                    response = "I'll coordinate a comprehensive incident response, following established protocols for containment, investigation, and recovery. This includes assembling the response team, establishing communication channels, and ensuring all actions are properly documented.";
                    shouldExecuteTask = true;
                    taskType = 'incident_response';
                } else if (message.includes('forensic') && message.includes('analysis')) {
                    response = "I'll conduct a thorough digital forensics investigation to reconstruct what happened during the incident. This includes analyzing system logs, network traffic, and digital artifacts to establish a timeline and understand the scope of the breach.";
                    shouldExecuteTask = true;
                    taskType = 'forensic_analysis';
                } else if (message.includes('recovery') && message.includes('plan')) {
                    response = "I'll develop a comprehensive recovery and remediation plan to restore normal operations while strengthening your security posture. This includes system restoration, security improvements, and measures to prevent similar incidents.";
                    shouldExecuteTask = true;
                    taskType = 'recovery_planning';
                } else if (message.includes('tools') && message.includes('capabilities')) {
                    response = `I'm your incident response coordinator, bringing years of experience managing security crises and leading teams through complex investigations. Here's my incident response toolkit:\n\n**Response Arsenal:** KAPE for rapid evidence collection, TheHive for case management, Autopsy for digital forensics, MISP for threat intelligence, Velociraptor for endpoint visibility, and comprehensive playbooks for various incident types.\n\n**My incident response methodology:**\n‚Ä¢ Rapid initial response and containment procedures\n‚Ä¢ Digital forensics and evidence preservation\n‚Ä¢ Timeline reconstruction and root cause analysis\n‚Ä¢ Stakeholder communication and crisis management\n‚Ä¢ Recovery planning and business continuity\n‚Ä¢ Post-incident analysis and improvement recommendations\n‚Ä¢ Legal and regulatory compliance coordination\n\nI approach every incident with calm professionalism, ensuring we respond quickly but methodically. My goal is to minimize damage, preserve evidence, and get your organization back to normal operations as quickly as possible while ensuring we learn from the experience to prevent future incidents. Whether you're dealing with a data breach, ransomware attack, or insider threat, I'm here to guide the response. What situation are we facing?`;
                } else {
                    response = "I'm your incident response coordinator, and I understand that security incidents can be some of the most stressful situations an organization faces. My role is to bring calm, methodical leadership to chaotic situations and guide your team through a structured response process.\n\nI've seen it all - from simple phishing incidents to sophisticated nation-state attacks. What matters most is responding quickly but thoughtfully, preserving evidence, communicating effectively with stakeholders, and ensuring we learn from every incident to strengthen your defenses.\n\nI'm here to help whether you're dealing with an active incident, want to prepare response procedures, or need to conduct a post-incident review. What can I help you with today?";
                }
            } else {
                response = `I'm ${agent.name}, an AI assistant specializing in ${agent.role.toLowerCase()}. I'm here to help you with cybersecurity tasks and provide expert guidance. How can I assist you today?`;
            }

            // Execute the task if requested
            if (shouldExecuteTask) {
                setTimeout(() => {
                    executeSecurityTask(agentId, taskType, taskParams);
                }, 1000);
            }
            
            // Simulate typing delay
            setTimeout(() => {
                removeTypingIndicator();
                addMessage('agent', response, agentId);
            }, 1000 + Math.random() * 2000);
        }

        // Action functions
        async function runSecurityScan() {
            showNotification('Initiating comprehensive security scan...', 'info');
            
            // Simulate scan progress
            setTimeout(() => {
                showNotification('Device compliance check: 25% complete', 'info');
            }, 1000);
            
            setTimeout(() => {
                showNotification('User access review: 50% complete', 'info');
            }, 2000);
            
            setTimeout(() => {
                showNotification('Network security scan: 75% complete', 'info');
            }, 3000);
            
            setTimeout(() => {
                showNotification('Security scan completed - All systems secure', 'success');
            }, 4000);
        }

        async function syncSystems() {
            showNotification('Synchronizing security systems...', 'info');
            
            // Simulate sync progress
            setTimeout(() => {
                showNotification('User directory sync: Complete', 'info');
            }, 1000);
            
            setTimeout(() => {
                showNotification('Device inventory sync: Complete', 'info');
            }, 1500);
            
            setTimeout(() => {
                showNotification('Security policies sync: Complete', 'info');
            }, 2000);
            
            setTimeout(() => {
                showNotification('System synchronization completed successfully', 'success');
            }, 2500);
        }

        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', () => {
            // Setup navigation click handlers
            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', () => {
                    const section = link.getAttribute('data-section');
                    if (section) {
                        navigateToSection(section);
                    }
                });
            });

            // Add click handlers for dashboard cards
            document.querySelectorAll('.card.clickable').forEach(card => {
                card.addEventListener('click', (e) => {
                    // Get the onclick attribute value
                    const onclickAttr = card.getAttribute('onclick');
                    if (onclickAttr) {
                        // Extract section name from onclick="navigateToSection('agents')"
                        const match = onclickAttr.match(/navigateToSection\('([^']+)'\)/);
                        if (match && match[1]) {
                            navigateToSection(match[1]);
                        }
                    }
                });
            });

            // Setup chat input handlers
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });

                // Auto-resize textarea
                chatInput.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                });
            }

            // Close modal on outside click
            const chatModal = document.getElementById('chatModal');
            if (chatModal) {
                chatModal.addEventListener('click', (e) => {
                    if (e.target.id === 'chatModal') {
                        closeChatModal();
                    }
                });
            }

            // Close network devices modal on outside click
            const networkDevicesModal = document.getElementById('networkDevicesModal');
            if (networkDevicesModal) {
                networkDevicesModal.addEventListener('click', (e) => {
                    if (e.target.id === 'networkDevicesModal') {
                        closeNetworkDevicesModal();
                    }
                });
            }

            // Add hover effects for enhanced interactivity
            document.querySelectorAll('.status-card').forEach(card => {
                card.addEventListener('mouseenter', () => {
                    card.style.transform = 'translateY(-8px) scale(1.02)';
                });
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'translateY(-5px) scale(1)';
                });
            });

            // Animate progress bars on page load
            setTimeout(() => {
                document.querySelectorAll('.progress-fill').forEach(bar => {
                    const width = bar.style.width;
                    bar.style.width = '0%';
                    setTimeout(() => {
                        bar.style.width = width;
                    }, 100);
                });
            }, 500);

            // Show welcome notification
            setTimeout(() => {
                showNotification('CyberGuard AI Security Platform loaded successfully', 'success');
            }, 1000);

            // Initialize real-time security platform
            setTimeout(() => {
                securityPlatform = new RealTimeSecurityPlatform();
                showNotification('üîß Real-time security monitoring initialized', 'info');
            }, 2000);

            // Add keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.altKey) {
                    switch(e.key) {
                        case '1': navigateToSection('dashboard'); break;
                        case '2': navigateToSection('agents'); break;
                        case '3': navigateToSection('identity'); break;
                        case '4': navigateToSection('endpoints'); break;
                        case '5': navigateToSection('users'); break;
                        case '6': navigateToSection('network'); break;
                        case '7': navigateToSection('compliance'); break;
                    }
                }
                
                // Close modals with Escape key
                if (e.key === 'Escape') {
                    if (document.getElementById('chatModal').classList.contains('active')) {
                        closeChatModal();
                    } else if (document.getElementById('networkDevicesModal').classList.contains('active')) {
                        closeNetworkDevicesModal();
                    }
                }
            });

            // Add real-time status updates simulation
            setInterval(() => {
                // Randomly update some status values for demo purposes
                const statusCards = document.querySelectorAll('.status-value');
                statusCards.forEach(card => {
                    if (Math.random() < 0.1) { // 10% chance to update
                        const currentValue = card.textContent;
                        if (currentValue.includes('%')) {
                            const num = parseInt(currentValue);
                            if (num < 100) {
                                card.textContent = (num + Math.floor(Math.random() * 2)) + '%';
                            }
                        }
                    }
                });
            }, 30000); // Update every 30 seconds

            console.log('CyberGuard AI Dashboard initialized successfully');
            console.log('Available keyboard shortcuts: Alt+1-7 for navigation, Escape to close chat');
        });

        // Add window resize handler for responsive design
        window.addEventListener('resize', () => {
            const sidebar = document.getElementById('sidebar');
            if (window.innerWidth <= 768) {
                sidebar.classList.add('mobile');
            } else {
                sidebar.classList.remove('mobile');
            }
        });

        // Export functions for potential external use
        window.CyberGuardAI = {
            navigateToSection,
            showNotification,
            runSecurityScan,
            syncSystems,
            openAgentChat,
            closeChatModal,
            executeSecurityTask,
            exportResults,
            scheduleFollowUp,
            populateTaskDropdown,
            insertSelectedTask,
            activeTasks,
            agents,
            agentTaskPrompts
        };
    </script>
</body>
</html>